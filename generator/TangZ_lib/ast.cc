#include "ast.h"

#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Type.h>
#include <llvm/IR/Verifier.h>
#include <llvm/Support/JSON.h>

#include <cassert>
#include <cstdio>
#include <string>
#include <utility>

#include "llvm/ADT/APFloat.h"
#include "llvm/ADT/APInt.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Value.h"

// Use the map and the unique id generated by llvm to find all the ast nodes.
std::map<std::string, tz_ast_class::Object *> GlobalSymbolAstMap;
std::vector<tz_ast_utils::WhileRangeControl> WhileStack;
// The Module has maintain a map for global values,
// We just need to maintain the map for local values in compound stmt(Change!)
std::map<std::string, llvm::Value *> LocalSymbolValueMap;
std::map<std::string, llvm::Constant *> GlobalSymbolValueMap;
llvm::BasicBlock *GlobalRetBB;

// #define DEBUG
/********************************
 * Constructors of all the AST nodes in tz_ast_class
 ********************************/

/********************************
 *  Expr
 *  Literal: IntegerLiteral, FloatingLiteral, StringLiteral
 *  BinaryExpr
 *  UnaryExpr
 *  CallExpr
 *  DeclRefExpr
 *  ImplicitCastExpr
 *  InitListExpr
 *  ArraySubscriptExpr
 ********************************/
tz_ast_class::IntegerLiteral::IntegerLiteral(
    llvm::LLVMContext &llvm_context, const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("IntegerLiteral\n");
#endif
  // IntegerLiteral May be int or long or longlong
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get value
  if (type->isIntegerTy(32)) {
    // int
    value = llvm::ConstantInt::get(
        llvm::Type::getInt32Ty(llvm_context),
        llvm::APInt(type->getIntegerBitWidth(),
                    json_tree->getString("value")->str(), 10));
  } else if (type->isIntegerTy(64)) {
    // long long
    value = llvm::ConstantInt::get(
        llvm::Type::getInt64Ty(llvm_context),
        llvm::APInt(type->getIntegerBitWidth(),
                    json_tree->getString("value")->str(), 10));
  } else {
    assert("IntegerLiteral Initialization False" && false);
  }
}

tz_ast_class::FloatingLiteral::FloatingLiteral(
    llvm::LLVMContext &llvm_context, const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("FloatingLiteral\n");
#endif
  // FloatingLiteral May be float or double
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get value
  if (type->isFloatTy()) {
    // float
    value = llvm::ConstantFP::get(
        llvm::Type::getFloatTy(llvm_context),
        llvm::APFloat(llvm::APFloatBase().IEEEsingle(),
                      json_tree->getString("value")->str()));
  } else if (type->isDoubleTy()) {
    value = llvm::ConstantFP::get(
        llvm::Type::getDoubleTy(llvm_context),
        llvm::APFloat(llvm::APFloatBase().IEEEdouble(),
                      json_tree->getString("value")->str()));
  } else {
    assert("FloatingLiteral Initialization False" && false);
  }
}

tz_ast_class::StringLiteral::StringLiteral(
    llvm::LLVMContext &llvm_context, const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("StringLiteral\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  std::string _value = json_tree->getString("value")->str();
  // remove the " at the head and tail
  _value = _value.substr(1, _value.size() - 2);
  // Finished! TODO(Need to process stupid chars): May be wrong!
  _value = tz_ast_utils::Unescape(_value);
  while (_value.size() < type->getArrayNumElements()) {
    _value += '\0';
  }
  assert("Unescaped value string is as long as length defined by type" &&
         _value.size() == type->getArrayNumElements());
  if (type->isArrayTy()) {
    // array
    // disable a null terminator added
    value = llvm::ConstantDataArray::getString(llvm_context, _value, false);
  } else {
    assert("FloatingLiteral Initialization False" && false);
  }
}

tz_ast_class::BinaryExpr::BinaryExpr(llvm::LLVMContext &llvm_context,
                                     const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("BinaryExpr\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get op
  std::string BinaryOPString = json_tree->getString("opcode")->str();
  op = tz_ast_utils::ParsingBinaryOp(BinaryOPString);

  // Get lhs and rhs
  auto lhs_json = (*json_tree->getArray("inner"))[0].getAsObject();
  auto rhs_json = (*json_tree->getArray("inner"))[1].getAsObject();

  lhs = dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, lhs_json));
  rhs = dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, rhs_json));
}

tz_ast_class::UnaryExpr::UnaryExpr(llvm::LLVMContext &llvm_context,
                                   const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("UnaryExpr\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get op
  std::string UnaryOPString = json_tree->getString("opcode")->str();
  op = tz_ast_utils::ParsingUnaryOp(UnaryOPString);

  // Get rhs
  auto rhs_json = (*json_tree->getArray("inner"))[0].getAsObject();
  rhs = dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, rhs_json));
}

tz_ast_class::DeclRefExpr::DeclRefExpr(llvm::LLVMContext &llvm_context,
                                       const llvm::json::Object *json_tree) {
  /******
   * All the reference will go to here,
        * including the reference to the global
        ,local,parameter and FUNCTIONS!!!
        IT IS VITAL to considerate the Feferee findings
   ******/
  // Initialize the ExprCatgry
#ifdef DEBUG
  printf("DeclRefExpr\n");
#endif
  ExprCatgry = tz_ast_type::lvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  _type = _type.substr(0, _type.find('('));
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get DeclRefee
  auto DeclRefee_ID =
      json_tree->getObject("referencedDecl")->getString("id")->str();
  // Finished! TODO(to be finished): Think of the global map strategy
  DeclRefee = dynamic_cast<Decl *>(GlobalSymbolAstMap[DeclRefee_ID]);
}

tz_ast_class::ImplicitCastExpr::ImplicitCastExpr(
    llvm::LLVMContext &llvm_context, const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("ImplicitCastExpr\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get CastCatgry
  std::string CastOPString = json_tree->getString("castKind")->str();
  CastCatgry = tz_ast_utils::ParsingImplicitCast(CastOPString);

  // Get castExpr
  auto castExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
  castExpr =
      dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, castExpr_json));
}

tz_ast_class::InitListExpr::InitListExpr(llvm::LLVMContext &llvm_context,
                                         const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("InitListExpr\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);
  // Get initExprs
  auto initExprs_json = json_tree->getArray("inner");
  if (initExprs_json == nullptr) {
    initExprs_json = json_tree->getArray("array_filler");
  }
  // Get isInited
  isInited = false;
  for (auto &initExpr_json : *initExprs_json) {
    if (initExpr_json == initExprs_json->front() &&
        initExpr_json.getAsObject()->getString("kind")->str() ==
            "ImplicitValueInitExpr") {
      // Check Whether the element is inited
      isInited = true;
      continue;
    }
    initExprs.push_back(dynamic_cast<Expr *>(
        tz_ast_utils::BuildAST(llvm_context, initExpr_json.getAsObject())));
  }
}

tz_ast_class::ArraySubscriptExpr::ArraySubscriptExpr(
    llvm::LLVMContext &llvm_context, const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("ArraySubscriptExpr\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::lvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get ArrayBase
  auto ArrayBase_json = (*json_tree->getArray("inner"))[0].getAsObject();
  ArrayBase = dynamic_cast<Expr *>(
      tz_ast_utils::BuildAST(llvm_context, ArrayBase_json));

  assert("ArraySubscriptExpr: ArrayBase is null!" && ArrayBase != nullptr);
  // Get ArrayIdx
  auto ArrayIdx_json = (*json_tree->getArray("inner"))[1].getAsObject();
  ArrayIdx =
      dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, ArrayIdx_json));
  assert("ArraySubscriptExpr: ArrayIdx is null!" && ArrayIdx != nullptr);
}

tz_ast_class::CallExpr::CallExpr(llvm::LLVMContext &llvm_context,
                                 const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("CallExpr\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get callee
  auto callee_json = (*json_tree->getArray("inner"))[0].getAsObject();
  callee =
      dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, callee_json));

  // Get CalleeArgs
  auto CalleeArgs_json = json_tree->getArray("inner");
  for (auto &CalleeArg_json : *CalleeArgs_json) {
    if (CalleeArg_json == CalleeArgs_json->front()) {
      // Jump the callee
      continue;
    }
    CalleeArgs.push_back(dynamic_cast<Expr *>(
        tz_ast_utils::BuildAST(llvm_context, CalleeArg_json.getAsObject())));
  }
}

tz_ast_class::ParenExpr::ParenExpr(llvm::LLVMContext &llvm_context,
                                   const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("ParenExpr\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;

  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get parenExpr
  auto parenExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
  inParenExpr = dynamic_cast<Expr *>(
      tz_ast_utils::BuildAST(llvm_context, parenExpr_json));
}

/********************************
 *  Decl
 *  TranslationUnitDecl
 *  VarDecl
 *  ParmVarDecl
 *  FunctionDecl
 ********************************/
tz_ast_class::TranslationUnitDecl::TranslationUnitDecl(
    llvm::LLVMContext &llvm_context, const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("TranslationUnitDecl\n");
#endif
  // No Name and type for TranslationUnitDecl
  type = nullptr;
  name = "";
  auto decls_json = json_tree->getArray("inner");
  for (auto &decl_json : *decls_json) {
    auto isGlobalVarDecl = false;
    if (decl_json.getAsObject()->getString("kind")->str() == "VarDecl") {
      isGlobalVarDecl = true;
    }
    Decls.push_back(dynamic_cast<Decl *>(tz_ast_utils::BuildAST(
        llvm_context, decl_json.getAsObject(), isGlobalVarDecl)));
    if (Decls.size() && Decls.back() == nullptr) {
      Decls.pop_back();
      assert("Building TranslationUnitDecl Failure: nullptr in the Decls" &&
             Decls.back() != nullptr);
    }
  }
}

tz_ast_class::VarDecl::VarDecl(llvm::LLVMContext &llvm_context,
                               const llvm::json::Object *json_tree,
                               const bool _isGlobal) {
#ifdef DEBUG
  printf("VarDecl\n");
#endif
  std::string VarDeclID = json_tree->getString("id")->str();
  // Find out whether the varDecl is global
  isGlobal = _isGlobal;
  // By default, the Var is not a const
  isConst = false;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    isConst = true;
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get name(unique)
  name = json_tree->getString("name")->str() + VarDeclID;

  // Get initExpr
  isInited = false;
  if (json_tree->get("inner") != nullptr) {
    isInited = true;
    auto initExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
    InitExpr = dynamic_cast<Expr *>(
        tz_ast_utils::BuildAST(llvm_context, initExpr_json));
  }

  // Store in the global map
  assert("Duplicate ID, already in Map!" &&
         GlobalSymbolAstMap.find(VarDeclID) == GlobalSymbolAstMap.end());
  GlobalSymbolAstMap[VarDeclID] = this;
}

tz_ast_class::ParmVarDecl::ParmVarDecl(llvm::LLVMContext &llvm_context,
                                       const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("ParmVarDecl\n");
#endif
  std::string ParamVarDeclID = json_tree->getString("id")->str();
  // By default, the Var is not a const
  isConst = false;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    isConst = true;
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get name (unique)
  name = json_tree->getString("name")->str() + ParamVarDeclID;

  // Get initExpr
  isInited = false;
  if (json_tree->getObject("inner") != nullptr) {
    isInited = true;
    auto initExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
    InitExpr = dynamic_cast<Expr *>(
        tz_ast_utils::BuildAST(llvm_context, initExpr_json));
  }

  // Store in the global map
  assert("Duplicate ID, already in Map!" &&
         GlobalSymbolAstMap.find(ParamVarDeclID) == GlobalSymbolAstMap.end());
  GlobalSymbolAstMap[ParamVarDeclID] = this;
}

tz_ast_class::FunctionDecl::FunctionDecl(llvm::LLVMContext &llvm_context,
                                         const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("FunctionDecl\n");
#endif
  // Get the unique ID for reference
  std::string FuncDeclID = json_tree->getString("id")->str();
  // Judege whether the numebr of params is dynamic
  isVariadic = false;
  if (json_tree->get("isVariadic") != nullptr) {
    isVariadic = true;
  }
  if (json_tree->get("storageClass") != nullptr &&
      json_tree->getString("storageClass")->str() == "extern") {
    // No need to process the external functions
    isExternal = true;
    return;
  }
  isExternal = false;
  // By default, the Var is not a const
  isConst = false;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  // Just want to get the return type.
  _type = _type.substr(0, _type.find('('));
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    isConst = true;
    _type = _type.substr(6, _type.size() - 1);
  }
  ReturnType = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get name (unique)
  name = json_tree->getString("name")->str();

  // TODO(unknown): Finish the following parts
  auto ParmVarDeclsWithBody_json = json_tree->getArray("inner");
  if (ParmVarDeclsWithBody_json == nullptr) {
    // the function has no params and no body.
    assert("Duplicate ID, already in Map!" &&
           GlobalSymbolAstMap.find(FuncDeclID) == GlobalSymbolAstMap.end());
    GlobalSymbolAstMap[FuncDeclID] = this;
  }
  // Get ParmVarDecls
  std::vector<llvm::Type *> ParamTypes;
  for (auto &ParmVarDecl_json : *ParmVarDeclsWithBody_json) {
    if (ParmVarDecl_json.getAsObject()->getString("kind")->str() ==
        "CompoundStmt") {
      break;
    }
    ParmVarDecl *ParamDecl = dynamic_cast<ParmVarDecl *>(
        tz_ast_utils::BuildAST(llvm_context, ParmVarDecl_json.getAsObject()));
    assert("Building FuncDecl Failure: ParamVarDecl wrong!" &&
           ParamDecl != nullptr);
    ParamTypes.push_back(ParamDecl->type);
    // params.push_back(dynamic_cast<Decl *>(ParamDecl));
    params.push_back(ParamDecl);
  }

  type = llvm::FunctionType::get(ReturnType, ParamTypes, isVariadic);

  // Get body
  auto body_json = json_tree->getArray("inner")->back().getAsObject();
  // assert("The Function does not have body!" && body_json != nullptr);
  if (body_json != nullptr) {
    FuncStmt = dynamic_cast<CompoundStmt *>(
        tz_ast_utils::BuildAST(llvm_context, body_json));
  }

  // Store in the global map
  assert("Duplicate ID, already in Map!" &&
         GlobalSymbolAstMap.find(FuncDeclID) == GlobalSymbolAstMap.end());
  GlobalSymbolAstMap[FuncDeclID] = this;
}

/********************************
 *  Stmt
 *  CompoundStmt
 *  ReturnStmt
 *  IfStmt
 *  WhileStmt
 *  DoStmt
 *  NullStmt
 *  BreakStmt
 *  ContinueStmt
 *  DeclStmt
 ********************************/

tz_ast_class::CompoundStmt::CompoundStmt(llvm::LLVMContext &llvm_context,
                                         const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("CompoundStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::Compound;
  // Get Stmts
  auto Stmts_json = json_tree->getArray("inner");
  if (Stmts_json != nullptr) {
    for (auto &Stmt_json : *Stmts_json) {
      auto Stmt_to_be_add =
          tz_ast_utils::BuildAST(llvm_context, Stmt_json.getAsObject());
      InnerStmts.push_back(Stmt_to_be_add);
      if (InnerStmts.size() && typeid(*Stmt_to_be_add) == typeid(ReturnStmt)) {
        break;
      }
    }
  }
}

tz_ast_class::ReturnStmt::ReturnStmt(llvm::LLVMContext &llvm_context,
                                     const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("ReturnStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::Return;
  // Get returnExpr
  ReturnExpr = nullptr;
  if (json_tree->getArray("inner") != nullptr) {
    auto returnExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
    ReturnExpr = dynamic_cast<Expr *>(
        tz_ast_utils::BuildAST(llvm_context, returnExpr_json));
  }
}

tz_ast_class::IfStmt::IfStmt(llvm::LLVMContext &llvm_context,
                             const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("IfStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::If;
  // Get condExpr
  auto condExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
  IfCondExpr =
      dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, condExpr_json));
  // Get thenStmt
  auto thenStmt_json = (*json_tree->getArray("inner"))[1].getAsObject();
  ThenObj = dynamic_cast<Object *>(
      tz_ast_utils::BuildAST(llvm_context, thenStmt_json));
  assert(ThenObj != nullptr && "Then Obj of IFstmt is null!");
  // Get elseStmt
  hasElse = false;
  if (json_tree->getArray("inner")->size() == 3) {
    hasElse = true;
    auto elseStmt_json = (*json_tree->getArray("inner"))[2].getAsObject();
    ElseObj = dynamic_cast<Object *>(
        tz_ast_utils::BuildAST(llvm_context, elseStmt_json));
    assert(ElseObj != nullptr && "Then else of IFstmt is null!");
  }
}

tz_ast_class::WhileStmt::WhileStmt(llvm::LLVMContext &llvm_context,
                                   const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("WhileStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::While;
  // Get condExpr
  auto condExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
  WhileCondExpr =
      dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, condExpr_json));
  assert("While Cond is Null" && WhileCondExpr != nullptr);
  // Get body
  auto body_json = (*json_tree->getArray("inner"))[1].getAsObject();
  WhileObj =
      dynamic_cast<Stmt *>(tz_ast_utils::BuildAST(llvm_context, body_json));
  assert("Error: While has no body!" && WhileObj != nullptr);
}

tz_ast_class::DoStmt::DoStmt(llvm::LLVMContext &llvm_context,
                             const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("DoStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::While;
  // Get DoCondExpr
  auto condExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
  DoCondExpr =
      dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, condExpr_json));
  // Get body
  auto body_json = (*json_tree->getArray("inner"))[1].getAsObject();
  DoObj = dynamic_cast<Stmt *>(tz_ast_utils::BuildAST(llvm_context, body_json));
  assert("Error: Do has no body!" && DoObj != nullptr);
}

tz_ast_class::NullStmt::NullStmt(llvm::LLVMContext &llvm_context,
                                 const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("NullStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::Null;
  // Nothing else to do
}

tz_ast_class::BreakStmt::BreakStmt(llvm::LLVMContext &llvm_context,
                                   const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("BreakStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::Break;
  // Nothing else to do
}

tz_ast_class::ContinueStmt::ContinueStmt(llvm::LLVMContext &llvm_context,
                                         const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("ContinueStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::Continue;
  // Nothing else to do
}

tz_ast_class::DeclStmt::DeclStmt(llvm::LLVMContext &llvm_context,
                                 const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("DeclStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::Decl;
  // Get Decls
  auto Decls_json = json_tree->getArray("inner");
  for (auto &Decl_json : *Decls_json) {
    Decls.push_back(dynamic_cast<Decl *>(
        tz_ast_utils::BuildAST(llvm_context, Decl_json.getAsObject())));
  }
}

/********************************
 * Utils implementation
 ********************************/
tz_ast_class::Object *tz_ast_utils::BuildAST(
    llvm::LLVMContext &llvm_context, const llvm::json::Object *json_tree,
    const bool isGlobal) {
  // Remember to assert when there is no-matched kind
  std::string NodeKind = json_tree->getString("kind")->str();
  if (NodeKind == "IntegerLiteral") {
    return new tz_ast_class::IntegerLiteral(llvm_context, json_tree);
  } else if (NodeKind == "FloatingLiteral") {
    return new tz_ast_class::FloatingLiteral(llvm_context, json_tree);
  } else if (NodeKind == "StringLiteral") {
    return new tz_ast_class::StringLiteral(llvm_context, json_tree);
  } else if (NodeKind == "BinaryOperator") {
    return new tz_ast_class::BinaryExpr(llvm_context, json_tree);
  } else if (NodeKind == "UnaryOperator") {
    return new tz_ast_class::UnaryExpr(llvm_context, json_tree);
  } else if (NodeKind == "CallExpr") {
    return new tz_ast_class::CallExpr(llvm_context, json_tree);
  } else if (NodeKind == "DeclRefExpr") {
    return new tz_ast_class::DeclRefExpr(llvm_context, json_tree);
  } else if (NodeKind == "ImplicitCastExpr") {
    return new tz_ast_class::ImplicitCastExpr(llvm_context, json_tree);
  } else if (NodeKind == "InitListExpr") {
    return new tz_ast_class::InitListExpr(llvm_context, json_tree);
  } else if (NodeKind == "ArraySubscriptExpr") {
    return new tz_ast_class::ArraySubscriptExpr(llvm_context, json_tree);
  } else if (NodeKind == "ParenExpr") {
    return new tz_ast_class::ParenExpr(llvm_context, json_tree);
  } else if (NodeKind == "TranslationUnitDecl") {
    return new tz_ast_class::TranslationUnitDecl(llvm_context, json_tree);
  } else if (NodeKind == "VarDecl") {
    return new tz_ast_class::VarDecl(llvm_context, json_tree, isGlobal);
  } else if (NodeKind == "ParmVarDecl") {
    return new tz_ast_class::ParmVarDecl(llvm_context, json_tree);
  } else if (NodeKind == "FunctionDecl") {
    return new tz_ast_class::FunctionDecl(llvm_context, json_tree);
  } else if (NodeKind == "CompoundStmt") {
    return new tz_ast_class::CompoundStmt(llvm_context, json_tree);
  } else if (NodeKind == "ReturnStmt") {
    return new tz_ast_class::ReturnStmt(llvm_context, json_tree);
  } else if (NodeKind == "IfStmt") {
    return new tz_ast_class::IfStmt(llvm_context, json_tree);
  } else if (NodeKind == "WhileStmt") {
    return new tz_ast_class::WhileStmt(llvm_context, json_tree);
  } else if (NodeKind == "DoStmt") {
    return new tz_ast_class::DoStmt(llvm_context, json_tree);
  } else if (NodeKind == "NullStmt") {
    return new tz_ast_class::NullStmt(llvm_context, json_tree);
  } else if (NodeKind == "BreakStmt") {
    return new tz_ast_class::BreakStmt(llvm_context, json_tree);
  } else if (NodeKind == "ContinueStmt") {
    return new tz_ast_class::ContinueStmt(llvm_context, json_tree);
  } else if (NodeKind == "DeclStmt") {
    return new tz_ast_class::DeclStmt(llvm_context, json_tree);
  } else if (NodeKind == "TypedefDecl" || NodeKind == "array_filler") {
    return nullptr;
    // TODO(nullptr judgement): May be wrong;
  } else {
    printf("Current kind is %s\n", NodeKind.c_str());
    assert("BuildAST False, Wrong Json Kind" && false);
  }
}

std::string tz_ast_utils::StripTailChars(const std::string str, const char c) {
  int none_C_idx = str.size() - 1;
  while (str[none_C_idx] == ' ') {
    none_C_idx--;
  }
  ++none_C_idx;
  return str.substr(0, none_C_idx);
}
llvm::Type *tz_ast_utils::ParsingLLVMType(llvm::LLVMContext &llvm_context,
                                          std::string str) {
  // Notice: InitList is pretty hard
  //        Function Name and Array type is the most complicated

  str = StripTailChars(str, ' ');
#ifdef DEBUG
  // printf("ParsingLLVMType: %s\n", str.c_str());
#endif
  if (str == "void") {
    return llvm::Type::getVoidTy(llvm_context);
  } else if (str == "char") {
    return llvm::Type::getInt8Ty(llvm_context);
  } else if (str == "short") {
    return llvm::Type::getInt16Ty(llvm_context);
  } else if (str == "int" || str == "unsigned int") {
    return llvm::Type::getInt32Ty(llvm_context);
  } else if (str == "long" || str == "unsigned long") {
    return llvm::Type::getInt32PtrTy(llvm_context);
  } else if (str == "long long") {
    return llvm::Type::getInt64PtrTy(llvm_context);
  } else if (str == "float") {
    return llvm::Type::getFloatTy(llvm_context);
  } else if (str == "double") {
    return llvm::Type::getDoubleTy(llvm_context);
  } else if (str.find('[') != str.npos) {
    auto pos = str.find('[');
    // Get the int [3] 's 3
    auto ArraySizeStr = str.substr(pos + 1, str.find_first_of(']') - pos - 1);
    auto ArraySize = std::stoi(ArraySizeStr);
    // Remove the [3]
    str.replace(pos, str.find_first_of(']') - pos + 1, "");
    return llvm::ArrayType::get(ParsingLLVMType(llvm_context, str), ArraySize);
  } else if (str.find('*') != str.npos) {
    // Parsing type like int * & int (*)()
    auto pos = str.find("(*)");
    if (pos == str.npos) {
      // it is int *
      pos = str.find('*');
    }
    // remove the tailing * or (*)
    str = str.substr(0, pos);
    // get the type of array
    return llvm::PointerType::get(ParsingLLVMType(llvm_context, str), 0);
  } else {
    printf("ParsingLLVMType: %s\n", str.c_str());
    assert("ParsingLLVMType False" && false);
  }
}

tz_ast_type::BinaryOpCatgry tz_ast_utils::ParsingBinaryOp(std::string str) {
  if (str == "+") {
    return tz_ast_type::BinaryOpCatgry::Add;
  } else if (str == "-") {
    return tz_ast_type::BinaryOpCatgry::Sub;
  } else if (str == "*") {
    return tz_ast_type::BinaryOpCatgry::Mul;
  } else if (str == "/") {
    return tz_ast_type::BinaryOpCatgry::Div;
  } else if (str == "%") {
    return tz_ast_type::BinaryOpCatgry::Mod;
  } else if (str == "<") {
    return tz_ast_type::BinaryOpCatgry::Less;
  } else if (str == "<=") {
    return tz_ast_type::BinaryOpCatgry::LessEq;
  } else if (str == ">") {
    return tz_ast_type::BinaryOpCatgry::Greater;
  } else if (str == ">=") {
    return tz_ast_type::BinaryOpCatgry::GreaterEq;
  } else if (str == "=") {
    return tz_ast_type::BinaryOpCatgry::Eq;
  } else if (str == "==") {
    return tz_ast_type::BinaryOpCatgry::EqEq;
  } else if (str == "!=") {
    return tz_ast_type::BinaryOpCatgry::ExclaimEq;
  } else if (str == "&&") {
    return tz_ast_type::BinaryOpCatgry::AmpAmp;
  } else if (str == "||") {
    return tz_ast_type::BinaryOpCatgry::PipePipe;
  } else {
    assert("ParsingBinaryOp False" && false);
  }
}
tz_ast_type::UnaryOpCatgry tz_ast_utils::ParsingUnaryOp(std::string str) {
  if (str == "&") {
    return tz_ast_type::UnaryOpCatgry::U_FindAddr;
  } else if (str == "*") {
    return tz_ast_type::UnaryOpCatgry::U_Deref;
  } else if (str == "+") {
    return tz_ast_type::UnaryOpCatgry::U_Plus;
  } else if (str == "-") {
    return tz_ast_type::UnaryOpCatgry::U_Minus;
  } else if (str == "~") {
    return tz_ast_type::UnaryOpCatgry::U_Tilde;
  } else if (str == "!") {
    return tz_ast_type::UnaryOpCatgry::U_N;
  } else {
    assert("ParsingUnaryOp False" && false);
  }
}
tz_ast_type::CastCatgry tz_ast_utils::ParsingImplicitCast(std::string str) {
  if (str == "IntegralCast") {
    return tz_ast_type::CastCatgry::IntegralCast;
  } else if (str == "FloatingCast") {
    return tz_ast_type::CastCatgry::FloatingCast;
  } else if (str == "LValueToRValue") {
    return tz_ast_type::CastCatgry::LValueToRValue;
  } else if (str == "IntegralToFloating") {
    return tz_ast_type::CastCatgry::IntegralToFloat;
  } else if (str == "FloatingToIntegral") {
    return tz_ast_type::CastCatgry::FloatToIntegral;
  } else if (str == "FunctionToPointerDecay") {
    return tz_ast_type::CastCatgry::FunctionToPointerDecay;
  } else if (str == "ArrayToPointerDecay") {
    return tz_ast_type::CastCatgry::ArrayToPointerDecay;
  } else if (str == "BitCast") {
    return tz_ast_type::CastCatgry::BitCast;
  } else if (str == "NoOp") {
    return tz_ast_type::CastCatgry::NoOp;
  } else {
    assert("ParsingImplicitCast False" && false);
  }
}
std::string tz_ast_utils::Unescape(const std::string &str) {
  std::string result;
  for (std::size_t i = 0; i < str.length(); ++i) {
    if (str[i] == '\\') {
      ++i;
      if (i == str.length()) {
        // The string ends with a backslash
        assert("Invalid escape sequence ends with a backslash" && false);
      }
      switch (str[i]) {
        case 'n':
          result += '\n';
          break;
        case 't':
          result += '\t';
          break;
        case '\\':
          result += '\\';
          break;
        case '\"':
          result += '\"';
          break;
        case '\'':
          result += '\'';
          break;
        case 'r':
          result += '\r';
          break;
        case 'v':
          result += '\v';
          break;
        case 'f':
          result += '\f';
          break;
        case 'a':
          result += '\a';
          break;
        case 'b':
          result += '\b';
          break;
        default:
          // Unknown escape sequence
          assert("Invalid escape sequence ends with a backslash" && false);
      }
    } else {
      result += str[i];
    }
  }
  return result;
}

int tz_ast_utils::ConvertMatToVec(llvm::Type *&ArrayGeneralType) {
  int MatrixSize = 1;
  while (auto arraytype = llvm::dyn_cast<llvm::ArrayType>(ArrayGeneralType)) {
    MatrixSize *= arraytype->getNumElements();
    ArrayGeneralType = arraytype->getElementType();
  }
  return MatrixSize;
}
int tz_ast_utils::ConvertMatToVec2(llvm::Type *&ArrayGeneralType,
                                   llvm::ArrayType *&ArrayTopType) {
  int MatrixSize = ArrayGeneralType->getArrayNumElements();
  while (auto arraytype = llvm::dyn_cast<llvm::ArrayType>(ArrayGeneralType)) {
    MatrixSize *= arraytype->getNumElements();
    ArrayGeneralType = arraytype->getElementType();
  }
  return MatrixSize;
}

void tz_ast_utils::RaiseOperandType(llvm::Module &TheModule,
                                    llvm::LLVMContext &llvm_context,
                                    llvm::BasicBlock *BB, llvm::Value **lhs,
                                    llvm::Value **rhs, bool isInt) {
  auto lhs1 = *lhs;
  auto rhs1 = *rhs;
  llvm::IRBuilder<> builder(BB);
  if (isInt) {
    if (lhs1->getType()->getIntegerBitWidth() <
        rhs1->getType()->getIntegerBitWidth()) {
      if (lhs1->getType() == llvm::Type::getInt1Ty(llvm_context)) {
        *lhs = builder.CreateZExt(lhs1, rhs1->getType());
      } else {
        *lhs = builder.CreateSExt(lhs1, rhs1->getType());
      }
    } else if (lhs1->getType()->getIntegerBitWidth() >
               rhs1->getType()->getIntegerBitWidth()) {
      if (rhs1->getType() == llvm::Type::getInt1Ty(llvm_context)) {
        *rhs = builder.CreateZExt(rhs1, lhs1->getType());
      } else {
        *rhs = builder.CreateSExt(rhs1, lhs1->getType());
      }
    }
  } else {
    if (lhs1->getType()->isFloatTy() && rhs1->getType()->isDoubleTy()) {
      *lhs = builder.CreateFPExt(lhs1, rhs1->getType());
    } else if (lhs1->getType()->isDoubleTy() && rhs1->getType()->isFloatTy()) {
      *rhs = builder.CreateFPExt(rhs1, lhs1->getType());
    }
  }
  assert("RaiseOperandType Error: Both side's type is not identical." &&
         (*lhs)->getType() == (*rhs)->getType());
}

llvm::Constant *tz_ast_utils::CalConstValueForGlobalVar(tz_ast_class::Expr *E) {
  // Calculate the exp value at run time
  // Literal, Implicit, DeclRef, Unary, Binary
  // TODO(unknown): -FunctionCall!
  if (dynamic_cast<tz_ast_class::IntegerLiteral *>(E) ||
      dynamic_cast<tz_ast_class::FloatingLiteral *>(E) ||
      dynamic_cast<tz_ast_class::StringLiteral *>(E)) {
    return llvm::dyn_cast<llvm::Constant>(E->value);
  } else if (auto castExpr =
                 dynamic_cast<tz_ast_class::ImplicitCastExpr *>(E)) {
    auto subExpr = tz_ast_utils::CalConstValueForGlobalVar(castExpr->castExpr);
    assert(subExpr != nullptr && "subExpr of cast expr must be const");
    auto type = castExpr->type;
    switch (castExpr->CastCatgry) {
      case tz_ast_type::IntegralToFloat: {
        auto subExprInt = llvm::dyn_cast<llvm::ConstantInt>(subExpr);
        return llvm::ConstantFP::get(type, subExprInt->getSExtValue());
      }
      case tz_ast_type::FloatToIntegral: {
        auto subExprFP = llvm::dyn_cast<llvm::ConstantFP>(subExpr);
        return llvm::ConstantInt::get(
            type, subExprFP->getValueAPF().convertToDouble());
      }
      case tz_ast_type::IntegralCast: {
        auto subExprInt = llvm::dyn_cast<llvm::ConstantInt>(subExpr);
        return llvm::ConstantInt::get(type, subExprInt->getSExtValue());
      }
      case tz_ast_type::FloatingCast: {
        auto subExprFP = llvm::dyn_cast<llvm::ConstantFP>(subExpr);
        return llvm::ConstantFP::get(
            type, subExprFP->getValueAPF().convertToDouble());
      }
      case tz_ast_type::NoOp:
      case tz_ast_type::LValueToRValue: {
        return subExpr;
      }
      default: {
        assert("Failure in CalConstValueForGlobalVar, Wrong Castkind" && false);
      }
    }
  } else if (auto declRefExpr = dynamic_cast<tz_ast_class::DeclRefExpr *>(E)) {
    if (auto declExpr =
            dynamic_cast<tz_ast_class::VarDecl *>(declRefExpr->DeclRefee)) {
      assert("Failure in CalConstValueForGlobalVar, Decl should be const" &&
             declExpr->isConst);
      if (GlobalSymbolValueMap.find(declExpr->name) !=
          GlobalSymbolValueMap.end()) {
        return GlobalSymbolValueMap[declExpr->name];
      }
    } else {
      assert("Failure in CalConstValueForGlobalVar, Wrong Refkind" && false);
    }
  } else if (auto binaryExpr = dynamic_cast<tz_ast_class::BinaryExpr *>(E)) {
    auto lhs = tz_ast_utils::CalConstValueForGlobalVar(binaryExpr->lhs);
    auto rhs = tz_ast_utils::CalConstValueForGlobalVar(binaryExpr->rhs);
    assert("Failure in CalConstValueForGlobalVar, LHS should be const" &&
           lhs != nullptr);
    assert("Failure in CalConstValueForGlobalVar, RHS should be const" &&
           rhs != nullptr);
    auto op = binaryExpr->op;
    auto type = binaryExpr->type;
    if (llvm::isa<llvm::ConstantInt>(lhs) &&
        llvm::isa<llvm::ConstantInt>(rhs)) {
      auto lhsInt = llvm::dyn_cast<llvm::ConstantInt>(lhs);
      auto rhsInt = llvm::dyn_cast<llvm::ConstantInt>(rhs);
      switch (op) {
        case tz_ast_type::Add: {
          return llvm::ConstantInt::get(
              type, lhsInt->getSExtValue() + rhsInt->getSExtValue());
        }
        case tz_ast_type::Sub: {
          return llvm::ConstantInt::get(
              type, lhsInt->getSExtValue() - rhsInt->getSExtValue());
        }
        case tz_ast_type::Mul: {
          return llvm::ConstantInt::get(
              type, lhsInt->getSExtValue() * rhsInt->getSExtValue());
        }
        case tz_ast_type::Div: {
          return llvm::ConstantInt::get(
              type, lhsInt->getSExtValue() / rhsInt->getSExtValue());
        }
        case tz_ast_type::Mod: {
          return llvm::ConstantInt::get(
              type, lhsInt->getSExtValue() % rhsInt->getSExtValue());
        }
        default: {
          assert("Failure in CalConstValueForGlobalVar, Unknown BinType(INT)" &&
                 false);
        }
      }
    } else if (llvm::isa<llvm::ConstantFP>(lhs) &&
               llvm::isa<llvm::ConstantFP>(rhs)) {
      auto lhsFP = llvm::dyn_cast<llvm::ConstantFP>(lhs);
      auto rhsFP = llvm::dyn_cast<llvm::ConstantFP>(rhs);
      switch (op) {
        case tz_ast_type::Add: {
          return llvm::ConstantFP::get(type,
                                       lhsFP->getValue() + rhsFP->getValue());
        }
        case tz_ast_type::Sub: {
          return llvm::ConstantFP::get(type,
                                       lhsFP->getValue() - rhsFP->getValue());
        }
        case tz_ast_type::Mul: {
          auto temp = llvm::ConstantFP::get(
              type, lhsFP->getValue() * rhsFP->getValue());
          return temp;
        }
        case tz_ast_type::Div: {
          return llvm::ConstantFP::get(type,
                                       lhsFP->getValue() / rhsFP->getValue());
        }
        default: {
          assert("Failure in CalConstValueForGlobalVar, Unknown BinType(FP)" &&
                 false);
        }
      }
    } else {
      assert("Failure in CalConstValueForGlobalVar, Unknown BinOPType" &&
             false);
    }
  } else if (auto unaryExpr = dynamic_cast<tz_ast_class::UnaryExpr *>(E)) {
    auto rhs = tz_ast_utils::CalConstValueForGlobalVar(unaryExpr->rhs);
    assert("Failure in CalConstValueForGlobalVar, RHS should be const" &&
           rhs != nullptr);
    auto op = unaryExpr->op;
    auto type = unaryExpr->type;
    if (llvm::isa<llvm::ConstantInt>(rhs)) {
      auto rhsInt = llvm::dyn_cast<llvm::ConstantInt>(rhs);
      switch (op) {
        case tz_ast_type::U_Plus: {
          return llvm::ConstantInt::get(type, rhsInt->getSExtValue());
        }
        case tz_ast_type::U_Minus: {
          return llvm::ConstantInt::get(type, -rhsInt->getSExtValue());
        }
        default: {
          assert("Failure in CalConstValueForGlobalVar, Unknown UnaType(INT)" &&
                 false);
        }
      }
    } else if (llvm::isa<llvm::ConstantFP>(rhs)) {
      auto rhsFP = llvm::dyn_cast<llvm::ConstantFP>(rhs);
      switch (op) {
        case tz_ast_type::U_Plus: {
          return llvm::ConstantFP::get(type,
                                       rhsFP->getValueAPF().convertToDouble());
        }
        case tz_ast_type::U_Minus: {
          return llvm::ConstantFP::get(type,
                                       -rhsFP->getValueAPF().convertToDouble());
        }
        default: {
          assert("Failure in CalConstValueForGlobalVar, Unknown UnaType(FP)" &&
                 false);
        }
      }
    } else {
      assert("Failure in CalConstValueForGlobalVar, Unknown BinOPType" &&
             false);
    }
  } else {
    llvm::outs() << typeid(*E).name() << "\n";
    assert(
        "Failure in CalConstValueForGlobalVar, Unkown const Expr(May be "
        "CallExpr)" &&
        false);
  }
  // It is impossible to go here
  assert("Failure in CalConstValueForGlobalVar, Impossible flow" && false);
  return nullptr;
}

llvm::Constant *tz_ast_utils::CalConstArrayForGlobalVar(
    tz_ast_class::InitListExpr *E) {
  auto topArrayType = llvm::dyn_cast<llvm::ArrayType>(E->type);
  assert(
      "CalConstArrayForGlobalVar Failure! Const init list is not an Array!" &&
      topArrayType != nullptr);
  auto BasicType = topArrayType->getElementType();
  int MatrixSize =
      topArrayType->getNumElements() * tz_ast_utils::ConvertMatToVec(BasicType);
  std::vector<llvm::Constant *> elements;
  int idx = 0;
  tz_ast_utils::buildConstInitListHelper(E, elements, idx, MatrixSize,
                                         BasicType);
  return llvm::ConstantArray::get(llvm::ArrayType::get(BasicType, MatrixSize),
                                  elements);
}

void tz_ast_utils::buildConstInitListHelper(
    tz_ast_class::InitListExpr *E, std::vector<llvm::Constant *> &elements,
    int &idx, int MatrixSize, llvm::Type *BasicType) {
  auto arrayType = E->type;
  assert(arrayType->isArrayTy());
  int *nxtIdx = nullptr;
  if (E->isInited) {
    nxtIdx = new int(idx + MatrixSize);
  }
  int nextlevelElementNum =
      MatrixSize / llvm::dyn_cast<llvm::ArrayType>(arrayType)->getNumElements();
  for (auto initExpr : E->initExprs) {
    if (auto inilistExpr =
            dynamic_cast<tz_ast_class::InitListExpr *>(initExpr)) {
      buildConstInitListHelper(inilistExpr, elements, idx, nextlevelElementNum,
                               BasicType);
    } else {
      llvm::Constant *value = nullptr;
      value = CalConstValueForGlobalVar(initExpr);
      assert(value != nullptr && "value is not null");
      elements.push_back(value);
      idx++;
    }
  }

  if (nxtIdx != nullptr) {
    while (idx < *nxtIdx) {
      elements.push_back(
          llvm::Constant::getNullValue(BasicType));  // fill with NULL constant
      idx++;
    }
  }
}
llvm::BasicBlock *tz_ast_utils::buildInitListHelper(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *BB, tz_ast_class::InitListExpr *E,
    llvm::AllocaInst *arrayPtr, int &idx, int MatrixSize) {
  llvm::IRBuilder<> builder(BB);
  auto arrayType = E->type;
  assert(arrayType->isArrayTy());
  int *nxtIdx = nullptr;
  if (E->isInited) {
    nxtIdx = new int(idx + MatrixSize);
  }
  int nextlevelElementNum =
      MatrixSize / llvm::dyn_cast<llvm::ArrayType>(arrayType)->getNumElements();
  for (auto initExpr : E->initExprs) {
    if (auto initlistExpr =
            dynamic_cast<tz_ast_class::InitListExpr *>(initExpr)) {
      buildInitListHelper(TheModule, llvm_context, BB, initlistExpr, arrayPtr,
                          idx, nextlevelElementNum);
    } else {
      llvm::Value *value = nullptr;
      BB = initExpr->emit(TheModule, llvm_context, BB, &value);
      // get element pointer, store value in idx
      auto offset =
          llvm::ConstantInt::get(llvm::Type::getInt32Ty(llvm_context), idx);
      auto elementPtr = builder.CreateInBoundsGEP(arrayPtr, {offset});
      builder.CreateStore(value, elementPtr);
      idx++;
    }
  }
  if (nxtIdx != nullptr) {
    idx = *nxtIdx;
  }
  return BB;
}

/********************************
 * IR Emit Implementations
 ********************************/

/********************************
 *  Expr
 *  Literal: IntegerLiteral, FloatingLiteral, StringLiteral
 *  BinaryExpr
 *  UnaryExpr
 *  CallExpr
 *  DeclRefExpr
 *  ImplicitCastExpr
 *  InitListExpr
 *  ArraySubscriptExpr
 ********************************/

llvm::BasicBlock *tz_ast_class::IntegerLiteral::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  *ReturnValue = value;
  return PrevBB;
}

llvm::BasicBlock *tz_ast_class::FloatingLiteral::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  *ReturnValue = value;
  return PrevBB;
}

llvm::BasicBlock *tz_ast_class::StringLiteral::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  *ReturnValue = value;
  return PrevBB;
}

llvm::BasicBlock *tz_ast_class::BinaryExpr::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  llvm::Value *LHSValue = nullptr;
  llvm::Value *RHSValue = nullptr;
  auto LLVM_FLOAT_ZERO =
      llvm::ConstantFP::get(llvm::Type::getFloatTy(llvm_context), 0.0);
  auto LLVM_DOUBLE_ZERO =
      llvm::ConstantFP::get(llvm::Type::getDoubleTy(llvm_context), 0.0);
  *ReturnValue = nullptr;
  auto CurrentBB = PrevBB;
  CurrentBB = lhs->emit(TheModule, llvm_context, CurrentBB, &LHSValue);
  switch (op) {
    case tz_ast_type::Add: {
      CurrentBB = rhs->emit(TheModule, llvm_context, CurrentBB, &RHSValue);
      llvm::IRBuilder<> builder(CurrentBB);
      if (type->isIntegerTy()) {
        *ReturnValue = builder.CreateAdd(LHSValue, RHSValue);
      } else if (type->isFloatingPointTy()) {
        *ReturnValue = builder.CreateFAdd(LHSValue, RHSValue);
      } else {
        assert("BinaryEmit Failure(+), No correct type" && false);
      }
      return CurrentBB;
    }
    case tz_ast_type::Sub: {
      CurrentBB = rhs->emit(TheModule, llvm_context, CurrentBB, &RHSValue);
      llvm::IRBuilder<> builder(CurrentBB);
      if (type->isIntegerTy()) {
        *ReturnValue = builder.CreateSub(LHSValue, RHSValue);
      } else if (type->isFloatingPointTy()) {
        *ReturnValue = builder.CreateFSub(LHSValue, RHSValue);
      } else {
        assert("BinaryEmit Failure(-), No correct type" && false);
      }
      return CurrentBB;
    }
    case tz_ast_type::Mul: {
      CurrentBB = rhs->emit(TheModule, llvm_context, CurrentBB, &RHSValue);
      llvm::IRBuilder<> builder(CurrentBB);
      if (type->isIntegerTy()) {
        *ReturnValue = builder.CreateMul(LHSValue, RHSValue);
      } else if (type->isFloatingPointTy()) {
        *ReturnValue = builder.CreateFMul(LHSValue, RHSValue);
      } else {
        assert("BinaryEmit Failure(*), No correct type" && false);
      }
      return CurrentBB;
    }
    case tz_ast_type::Div: {
      CurrentBB = rhs->emit(TheModule, llvm_context, CurrentBB, &RHSValue);
      llvm::IRBuilder<> builder(CurrentBB);
      if (type->isIntegerTy()) {
        *ReturnValue = builder.CreateSDiv(LHSValue, RHSValue);
      } else if (type->isFloatingPointTy()) {
        *ReturnValue = builder.CreateFDiv(LHSValue, RHSValue);
      } else {
        assert("BinaryEmit Failure(/), No correct type" && false);
      }
      return CurrentBB;
    }
    case tz_ast_type::Mod: {
      CurrentBB = rhs->emit(TheModule, llvm_context, CurrentBB, &RHSValue);
      llvm::IRBuilder<> builder(CurrentBB);
      if (type->isIntegerTy()) {
        *ReturnValue = builder.CreateSRem(LHSValue, RHSValue);
      } else if (type->isFloatingPointTy()) {
        *ReturnValue = builder.CreateFRem(LHSValue, RHSValue);
      } else {
        assert("BinaryEmit Failure(%), No correct type" && false);
      }
      return CurrentBB;
    }
    case tz_ast_type::Less: {
      CurrentBB = rhs->emit(TheModule, llvm_context, CurrentBB, &RHSValue);
      llvm::IRBuilder<> builder(CurrentBB);
      if (type->isIntegerTy()) {
        // assert("LHS is not interger" && LHS)
        tz_ast_utils::RaiseOperandType(TheModule, llvm_context, CurrentBB,
                                       &LHSValue, &RHSValue, true);
        *ReturnValue = builder.CreateICmpSLT(LHSValue, RHSValue);
      } else if (type->isFloatingPointTy()) {
        tz_ast_utils::RaiseOperandType(TheModule, llvm_context, CurrentBB,
                                       &LHSValue, &RHSValue, false);
        *ReturnValue = builder.CreateFCmpOLT(LHSValue, RHSValue);
      } else {
        assert("BinaryEmit Failure(<), No correct type" && false);
      }
      return CurrentBB;
    }
    case tz_ast_type::LessEq: {
      CurrentBB = rhs->emit(TheModule, llvm_context, CurrentBB, &RHSValue);
      llvm::IRBuilder<> builder(CurrentBB);
      if (type->isIntegerTy()) {
        tz_ast_utils::RaiseOperandType(TheModule, llvm_context, CurrentBB,
                                       &LHSValue, &RHSValue, true);
        *ReturnValue = builder.CreateICmpSLE(LHSValue, RHSValue);
      } else if (type->isFloatingPointTy()) {
        tz_ast_utils::RaiseOperandType(TheModule, llvm_context, CurrentBB,
                                       &LHSValue, &RHSValue, false);
        *ReturnValue = builder.CreateFCmpOLE(LHSValue, RHSValue);
      } else {
        assert("BinaryEmit Failure(<=), No correct type" && false);
      }
      return CurrentBB;
    }
    case tz_ast_type::Greater: {
      CurrentBB = rhs->emit(TheModule, llvm_context, CurrentBB, &RHSValue);
      llvm::IRBuilder<> builder(CurrentBB);
      if (type->isIntegerTy()) {
        tz_ast_utils::RaiseOperandType(TheModule, llvm_context, CurrentBB,
                                       &LHSValue, &RHSValue, true);
        *ReturnValue = builder.CreateICmpSGT(LHSValue, RHSValue);
      } else if (type->isFloatingPointTy()) {
        tz_ast_utils::RaiseOperandType(TheModule, llvm_context, CurrentBB,
                                       &LHSValue, &RHSValue, false);
        *ReturnValue = builder.CreateFCmpOGT(LHSValue, RHSValue);
      } else {
        assert("BinaryEmit Failure(<=), No correct type" && false);
      }
      return CurrentBB;
    }
    case tz_ast_type::GreaterEq: {
      CurrentBB = rhs->emit(TheModule, llvm_context, CurrentBB, &RHSValue);
      llvm::IRBuilder<> builder(CurrentBB);
      if (type->isIntegerTy()) {
        tz_ast_utils::RaiseOperandType(TheModule, llvm_context, CurrentBB,
                                       &LHSValue, &RHSValue, true);
        *ReturnValue = builder.CreateICmpSGE(LHSValue, RHSValue);
      } else if (type->isFloatingPointTy()) {
        tz_ast_utils::RaiseOperandType(TheModule, llvm_context, CurrentBB,
                                       &LHSValue, &RHSValue, false);
        *ReturnValue = builder.CreateFCmpOGE(LHSValue, RHSValue);
      } else {
        assert("BinaryEmit Failure(<=), No correct type" && false);
      }
      return CurrentBB;
    }
    case tz_ast_type::Eq: {
      CurrentBB = rhs->emit(TheModule, llvm_context, CurrentBB, &RHSValue);
      llvm::IRBuilder<> builder(CurrentBB);
      builder.CreateStore(RHSValue, LHSValue);
      return CurrentBB;
    }
    case tz_ast_type::EqEq: {
      CurrentBB = rhs->emit(TheModule, llvm_context, CurrentBB, &RHSValue);
      llvm::IRBuilder<> builder(CurrentBB);
      if (type->isIntegerTy()) {
        tz_ast_utils::RaiseOperandType(TheModule, llvm_context, CurrentBB,
                                       &LHSValue, &RHSValue, true);
        *ReturnValue = builder.CreateICmpEQ(LHSValue, RHSValue);
      } else if (type->isFloatingPointTy()) {
        tz_ast_utils::RaiseOperandType(TheModule, llvm_context, CurrentBB,
                                       &LHSValue, &RHSValue, false);
        *ReturnValue = builder.CreateFCmpOEQ(LHSValue, RHSValue);
      } else {
        assert("BinaryEmit Failure(<=), No correct type" && false);
      }
      return CurrentBB;
    }
    case tz_ast_type::ExclaimEq: {
      CurrentBB = rhs->emit(TheModule, llvm_context, CurrentBB, &RHSValue);
      llvm::IRBuilder<> builder(CurrentBB);
      if (type->isIntegerTy()) {
        tz_ast_utils::RaiseOperandType(TheModule, llvm_context, CurrentBB,
                                       &LHSValue, &RHSValue, true);
        *ReturnValue = builder.CreateICmpNE(LHSValue, RHSValue);
      } else if (type->isFloatingPointTy()) {
        tz_ast_utils::RaiseOperandType(TheModule, llvm_context, CurrentBB,
                                       &LHSValue, &RHSValue, false);
        *ReturnValue = builder.CreateFCmpONE(LHSValue, RHSValue);
      } else {
        assert("BinaryEmit Failure(<=), No correct type" && false);
      }
      return CurrentBB;
    }
      // Notice!!! From now on, we need to take short-cut into consideration.
    case tz_ast_type::AmpAmp: {
      // tocheck: May be wrong.
      llvm::BasicBlock *AndTrueBB = llvm::BasicBlock::Create(
          llvm_context, "AndTrue", CurrentBB->getParent());
      llvm::BasicBlock *AndEndBB = llvm::BasicBlock::Create(
          llvm_context, "AndEnd", CurrentBB->getParent());

      llvm::IRBuilder<> builder(CurrentBB);

      // Short-Circut computing
      // Sysu-Clang Test Cases doesnot take Bool as basic value type, skip
      // assert(!LHSValue->getType()->isIntegerTy(1));
      if (LHSValue->getType()->isIntegerTy() &&
          !LHSValue->getType()->isIntegerTy(1)) {
        auto bitWidth = LHSValue->getType()->getIntegerBitWidth();
        LHSValue = builder.CreateICmpNE(
            LHSValue, llvm::ConstantInt::get(
                          llvm::Type::getIntNTy(llvm_context, bitWidth), 0));
      } else if (LHSValue->getType()->isFloatTy()) {
        LHSValue = builder.CreateFCmpONE(LHSValue, LLVM_FLOAT_ZERO);
      } else if (LHSValue->getType()->isDoubleTy()) {
        LHSValue = builder.CreateFCmpONE(LHSValue, LLVM_DOUBLE_ZERO);
      }
      builder.CreateCondBr(LHSValue, AndTrueBB, AndEndBB);

      CurrentBB = rhs->emit(TheModule, llvm_context, AndTrueBB, &RHSValue);
      builder.SetInsertPoint(CurrentBB);

      if (RHSValue->getType()->isIntegerTy() &&
          !RHSValue->getType()->isIntegerTy(1)) {
        auto bitWidth = RHSValue->getType()->getIntegerBitWidth();
        RHSValue = builder.CreateICmpNE(
            RHSValue, llvm::ConstantInt::get(
                          llvm::Type::getIntNTy(llvm_context, bitWidth), 0));
      } else if (RHSValue->getType()->isFloatTy()) {
        RHSValue = builder.CreateFCmpONE(RHSValue, LLVM_FLOAT_ZERO);
      } else if (RHSValue->getType()->isDoubleTy()) {
        RHSValue = builder.CreateFCmpONE(RHSValue, LLVM_DOUBLE_ZERO);
      }
      // For safety, explicitly set the terminator
      builder.CreateBr(AndEndBB);
      builder.SetInsertPoint(AndEndBB);
      *ReturnValue = builder.CreateAnd(LHSValue, RHSValue);

      return AndEndBB;
    }
    case tz_ast_type::PipePipe: {
      // tocheck: May be wrong.
      llvm::BasicBlock *OrFalseBB = llvm::BasicBlock::Create(
          llvm_context, "OrFalse", CurrentBB->getParent());
      llvm::BasicBlock *OrEndBB = llvm::BasicBlock::Create(
          llvm_context, "OrEnd", CurrentBB->getParent());

      llvm::IRBuilder<> builder(CurrentBB);

      // Short-Circut computing
      // Sysu-Clang Test Cases doesnot take Bool as basic value type, skip
      // assert(!LHSValue->getType()->isIntegerTy(1));
      if (LHSValue->getType()->isIntegerTy() &&
          !LHSValue->getType()->isIntegerTy(1)) {
        auto bitWidth = LHSValue->getType()->getIntegerBitWidth();
        LHSValue = builder.CreateICmpNE(
            LHSValue, llvm::ConstantInt::get(
                          llvm::Type::getIntNTy(llvm_context, bitWidth), 0));
      } else if (LHSValue->getType()->isFloatTy()) {
        LHSValue = builder.CreateFCmpONE(LHSValue, LLVM_FLOAT_ZERO);
      } else if (LHSValue->getType()->isDoubleTy()) {
        LHSValue = builder.CreateFCmpONE(LHSValue, LLVM_DOUBLE_ZERO);
      }
      // Since in OR it is true that will short-Cutting, so reverse the
      // jump-point
      builder.CreateCondBr(LHSValue, OrEndBB, OrFalseBB);

      CurrentBB = rhs->emit(TheModule, llvm_context, OrFalseBB, &RHSValue);
      builder.SetInsertPoint(CurrentBB);

      if (RHSValue->getType()->isIntegerTy() &&
          !RHSValue->getType()->isIntegerTy(1)) {
        auto bitWidth = RHSValue->getType()->getIntegerBitWidth();
        RHSValue = builder.CreateICmpNE(
            RHSValue, llvm::ConstantInt::get(
                          llvm::Type::getIntNTy(llvm_context, bitWidth), 0));
      } else if (RHSValue->getType()->isFloatTy()) {
        RHSValue = builder.CreateFCmpONE(RHSValue, LLVM_FLOAT_ZERO);
      } else if (RHSValue->getType()->isDoubleTy()) {
        RHSValue = builder.CreateFCmpONE(RHSValue, LLVM_DOUBLE_ZERO);
      }
      // For safety, explicitly set the terminator
      builder.CreateBr(OrEndBB);
      builder.SetInsertPoint(OrEndBB);
      *ReturnValue = builder.CreateAnd(LHSValue, RHSValue);

      return OrEndBB;
    }
    default:
      assert("BinaryEmit Failure, No correct op" && false);
  }
  // It is impossible to go here!
  assert("BinaryEmit Failure: Impossible Control Flow to go here!" && false);
  return nullptr;
}

llvm::BasicBlock *tz_ast_class::UnaryExpr::emit(llvm::Module &TheModule,
                                                llvm::LLVMContext &llvm_context,
                                                llvm::BasicBlock *PrevBB,
                                                llvm::Value **ReturnValue) {
  llvm::Value *RHSValue = nullptr;
  *ReturnValue = nullptr;
  auto CurrentBB = PrevBB;
  CurrentBB = rhs->emit(TheModule, llvm_context, CurrentBB, &RHSValue);
  llvm::IRBuilder<> builder(CurrentBB);

  switch (op) {
    case tz_ast_type::U_Plus: {
      // +
      *ReturnValue = RHSValue;
      break;
    }
    case tz_ast_type::U_Minus: {
      // -
      if (type->isIntegerTy()) {
        if (RHSValue->getType()->isIntegerTy(1)) {
          // bool
          RHSValue = builder.CreateZExt(RHSValue,
                                        llvm::Type::getInt32Ty(llvm_context));
        }
        *ReturnValue = builder.CreateNeg(RHSValue);
      } else if (type->isFloatingPointTy()) {
        *ReturnValue = builder.CreateFNeg(RHSValue);
      } else {
        assert("UnaryEmit Failure(-), No correct type" && false);
      }
      break;
    }
    case tz_ast_type::U_N: {
      // !
      auto RHSValueType = RHSValue->getType();
      if (RHSValueType->isIntegerTy()) {
        auto bitWidth = RHSValueType->getIntegerBitWidth();
        *ReturnValue = builder.CreateICmpEQ(
            RHSValue, llvm::ConstantInt::get(
                          llvm::Type::getIntNTy(llvm_context, bitWidth), 0));
      } else if (RHSValueType->isFloatTy()) {
        *ReturnValue = builder.CreateFCmpOEQ(
            RHSValue,
            llvm::ConstantFP::get(llvm::Type::getFloatTy(llvm_context), 0.0));
      } else if (RHSValueType->isDoubleTy()) {
        *ReturnValue = builder.CreateFCmpOEQ(
            RHSValue,
            llvm::ConstantFP::get(llvm::Type::getDoubleTy(llvm_context), 0.0));
      } else {
        assert("UnaryEmit Failure(!), No correct type" && false);
      }
      break;
    }
    default: {
      assert("UnaryEmit Failure(No +-!), No correct op" && false);
    }
  }

  return CurrentBB;
}

llvm::BasicBlock *tz_ast_class::CallExpr::emit(llvm::Module &TheModule,
                                               llvm::LLVMContext &llvm_context,
                                               llvm::BasicBlock *PrevBB,
                                               llvm::Value **ReturnValue) {
  auto CurrBB = PrevBB;
  llvm::IRBuilder<> builder(CurrBB);
  llvm::Value *FunctionPtr = nullptr;
  CurrBB = callee->emit(TheModule, llvm_context, CurrBB, &FunctionPtr);
  assert("No such function, emit failure" && FunctionPtr != nullptr &&
         llvm::isa<llvm::Function>(FunctionPtr) != false);
  std::vector<llvm::Value *> argVec;
  llvm::Value *argValue = nullptr;
  for (auto &arg : CalleeArgs) {
    CurrBB = arg->emit(TheModule, llvm_context, CurrBB, &argValue);
    argVec.push_back(argValue);
  }
  builder.SetInsertPoint(CurrBB);
  *ReturnValue =
      builder.CreateCall(llvm::dyn_cast<llvm::Function>(FunctionPtr), argVec);
  return CurrBB;
}

llvm::BasicBlock *tz_ast_class::DeclRefExpr::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  auto CurrBB = PrevBB;
  llvm::IRBuilder<> builder(CurrBB);
  auto name = DeclRefee->name;
  llvm::Value *RetValue = nullptr;
  // Array Helpers: get zero
  auto LLVM_ZERO =
      llvm::ConstantInt::get(llvm::Type::getInt32Ty(llvm_context), 0);

  if (LocalSymbolValueMap.find(name) != LocalSymbolValueMap.end()) {
    auto LocalSymbol = LocalSymbolValueMap[name];
    if (LocalSymbol->getType()->isArrayTy()) {
      // is array
      auto ArrayConvertedPtr =
          builder.CreateInBoundsGEP(LocalSymbol, {LLVM_ZERO, LLVM_ZERO});
      assert("ReferringExpr wrong!" &&
             ArrayConvertedPtr->getType()->getPointerElementType() ==
                 LocalSymbol->getType()->getArrayElementType());
      RetValue = ArrayConvertedPtr;
    } else {
      RetValue = LocalSymbol;
    }
  } else if (TheModule.getGlobalVariable(name)) {
    auto GlobalSymbol = TheModule.getGlobalVariable(name);
    if (GlobalSymbol->getType()->getElementType()->isArrayTy()) {
      // is array
      auto ArrayConvertedPtr =
          builder.CreateInBoundsGEP(GlobalSymbol, {LLVM_ZERO, LLVM_ZERO});
      assert(
          "ReferringExpr wrong!" &&
          ArrayConvertedPtr->getType()->getPointerElementType() ==
              GlobalSymbol->getType()->getElementType()->getArrayElementType());
      RetValue = ArrayConvertedPtr;
    } else {
      RetValue = GlobalSymbol;
    }
  } else if (TheModule.getFunction(name)) {
    // Reference Function
    RetValue = TheModule.getFunction(name);
  } else {
    assert(false && "unknown variable");
  }
  *ReturnValue = RetValue;
  return CurrBB;
}

llvm::BasicBlock *tz_ast_class::ImplicitCastExpr::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  // Finished! TODO(tocheck): Big implementation problems, rebuild.
  // Implementation similar to parsing.
  auto CurrentBB = PrevBB;
  llvm::IRBuilder<> builder(CurrentBB);
  llvm::Value *castValue = nullptr;
  CurrentBB = castExpr->emit(TheModule, llvm_context, CurrentBB, &castValue);
  switch (CastCatgry) {
    case tz_ast_type::IntegralCast: {
      builder.SetInsertPoint(CurrentBB);
      if (type->isIntegerTy()) {
        *ReturnValue = builder.CreateIntCast(castValue, type, false);
      } else if (type->isFloatingPointTy()) {
        *ReturnValue = builder.CreateFPCast(castValue, type);
      } else {
        assert("IntegralCast Failure" && false);
      }
      break;
    }
    case tz_ast_type::FloatingCast: {
      builder.SetInsertPoint(CurrentBB);
      if (type->isIntegerTy()) {
        *ReturnValue = builder.CreateFPToSI(castValue, type);
      } else if (type->isFloatingPointTy()) {
        *ReturnValue = builder.CreateFPCast(castValue, type);
      } else {
        assert("FloatingCast Failure" && false);
      }
      break;
    }
    case tz_ast_type::LValueToRValue: {
      builder.SetInsertPoint(CurrentBB);
      *ReturnValue = builder.CreateLoad(castValue);
      break;
    }
    case tz_ast_type::IntegralToFloat: {
      builder.SetInsertPoint(CurrentBB);
      *ReturnValue = builder.CreateSIToFP(castValue, type);
      break;
    }
    case tz_ast_type::FloatToIntegral: {
      builder.SetInsertPoint(CurrentBB);
      *ReturnValue = builder.CreateFPToSI(castValue, type);
      break;
    }
    case tz_ast_type::FunctionToPointerDecay: {
      auto FunctionPtr = castValue;
      auto TheFunction = TheModule.getFunction(FunctionPtr->getName());
      if (TheFunction == nullptr) {
        assert(false && "function not found");
      }
      *ReturnValue = TheFunction;
      break;
    }
    case tz_ast_type::ArrayToPointerDecay:
    case tz_ast_type::BitCast:
    case tz_ast_type::NoOp: {
      // Has already emitted at the beginning
      *ReturnValue = castValue;
      break;
    }
    default: {
      assert("EmittingImplicitCast False" && false);
      break;
    }
  }
  return CurrentBB;
}

llvm::BasicBlock *tz_ast_class::InitListExpr::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  auto CurrentBB = PrevBB;
  llvm::IRBuilder<> builder(CurrentBB);
  auto topArrayType = llvm::dyn_cast<llvm::ArrayType>(type);
  auto BasicType = topArrayType->getElementType();
  int MatrixSize =
      topArrayType->getNumElements() * tz_ast_utils::ConvertMatToVec(BasicType);
  auto arraySize =
      llvm::ConstantInt::get(llvm::Type::getInt32Ty(llvm_context), MatrixSize);
  auto arrayType = llvm::ArrayType::get(BasicType, MatrixSize);
  auto tmpPtr = builder.CreateAlloca(BasicType, arraySize);  // i32*
  int bitwidth = 0;
  if (BasicType->isIntegerTy()) {
    bitwidth = BasicType->getIntegerBitWidth();
    assert(bitwidth % 8 == 0 && "bitwidth is not a multiple of 8");
  } else if (BasicType->isDoubleTy()) {
    int bitwidth = 64;
  } else if (BasicType->isFloatTy()) {
    int bitwidth = 32;
  } else {
    assert(false && "unhandled type");
  }

  auto byteCnt = bitwidth / 8 * MatrixSize;
  auto byteCntConst =
      llvm::ConstantInt::get(llvm::Type::getInt32Ty(llvm_context), byteCnt);
  auto nullvalue =
      llvm::ConstantInt::get(llvm::Type::getInt8Ty(llvm_context), 0);
  builder.CreateMemSet(tmpPtr, nullvalue, byteCntConst, tmpPtr->getAlign());

  int idx = 0;
  CurrentBB = tz_ast_utils::buildInitListHelper(
      TheModule, llvm_context, CurrentBB, this, tmpPtr, idx, MatrixSize);
  *ReturnValue = tmpPtr;
  return CurrentBB;
}

llvm::BasicBlock *tz_ast_class::ArraySubscriptExpr::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  // Function: get the value in matrix
  auto CurrentBB = PrevBB;
  // Handle Base
  llvm::Value *BasePtr = nullptr;
  CurrentBB = ArrayBase->emit(TheModule, llvm_context, CurrentBB, &BasePtr);
  // Handle Index
  llvm::Value *IndexPtr = nullptr;
  CurrentBB = ArrayIdx->emit(TheModule, llvm_context, CurrentBB, &IndexPtr);

  // Flatten the matrix
  auto BasicType = type;
  int MatrixSize = tz_ast_utils::ConvertMatToVec(BasicType);

  // Emit IRs
  llvm::IRBuilder<> builder(CurrentBB);
  auto offset = builder.CreateMul(
      IndexPtr, llvm::ConstantInt::get(IndexPtr->getType(), MatrixSize));
  auto newArrayPtr = builder.CreateInBoundsGEP(BasePtr, {offset});
  *ReturnValue = newArrayPtr;
  return CurrentBB;
}
llvm::BasicBlock *tz_ast_class::ParenExpr::emit(llvm::Module &TheModule,
                                                llvm::LLVMContext &llvm_context,
                                                llvm::BasicBlock *PrevBB,
                                                llvm::Value **ReturnValue) {
  return inParenExpr->emit(TheModule, llvm_context, PrevBB, ReturnValue);
}
/********************************
 *  Decl
 *  TranslationUnitDecl
 *  VarDecl
 *  ParmVarDecl
 *  FunctionDecl
 ********************************/
llvm::BasicBlock *tz_ast_class::TranslationUnitDecl::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  // assert("TranslationUnitDecl has no body!" && false);
  if (Decls.size()) {
    for (auto &Decl : Decls) {
      assert("Decl is empty!" && Decl != nullptr);
      PrevBB = Decl->emit(TheModule, llvm_context, PrevBB, ReturnValue);
    }
  }
  return PrevBB;
}
llvm::BasicBlock *tz_ast_class::VarDecl::emit(llvm::Module &TheModule,
                                              llvm::LLVMContext &llvm_context,
                                              llvm::BasicBlock *PrevBB,
                                              llvm::Value **ReturnValue) {
  if (isGlobal) {
    if (isInited) {
      if (auto expr = dynamic_cast<tz_ast_class::InitListExpr *>(InitExpr)) {
        auto topArrayType = llvm::dyn_cast<llvm::ArrayType>(type);
        auto BasicType = topArrayType->getElementType();
        int MatrixSize = topArrayType->getNumElements() *
                         tz_ast_utils::ConvertMatToVec(BasicType);
        auto arraySize = llvm::ConstantInt::get(
            llvm::Type::getInt32Ty(llvm_context), MatrixSize);
        auto arrayType = llvm::ArrayType::get(BasicType, MatrixSize);
        TheModule.getOrInsertGlobal(name, arrayType);
        auto global = TheModule.getNamedGlobal(name);
        global->setInitializer(tz_ast_utils::CalConstArrayForGlobalVar(expr));
      } else {
        TheModule.getOrInsertGlobal(name, type);
        auto global = TheModule.getNamedGlobal(name);
        auto initValue = tz_ast_utils::CalConstValueForGlobalVar(InitExpr);
        GlobalSymbolValueMap[name] = initValue;
        global->setInitializer(initValue);
      }
    } else {
      if (type->isArrayTy()) {
        auto topArrayType = llvm::dyn_cast<llvm::ArrayType>(type);
        auto BasicType = topArrayType->getElementType();
        int MatrixSize = topArrayType->getNumElements() *
                         tz_ast_utils::ConvertMatToVec(BasicType);
        auto arraySize = llvm::ConstantInt::get(
            llvm::Type::getInt32Ty(llvm_context), MatrixSize);
        auto arrayType = llvm::ArrayType::get(BasicType, MatrixSize);
        TheModule.getOrInsertGlobal(name, arrayType);
        auto global = TheModule.getNamedGlobal(name);
        // SetdefaultZero
        global->setInitializer(llvm::ConstantAggregateZero::get(arrayType));
      } else {
        TheModule.getOrInsertGlobal(name, type);
        auto global = TheModule.getNamedGlobal(name);
        global->setInitializer(llvm::Constant::getNullValue(type));
      }
    }
    return nullptr;
  } else {  // Local Decls
    llvm::IRBuilder<> builder(PrevBB);
    if (isInited) {
      llvm::Value *initValue = nullptr;
      PrevBB = InitExpr->emit(TheModule, llvm_context, PrevBB, &initValue);
      builder.SetInsertPoint(PrevBB);
      if (auto initlistExpr =
              dynamic_cast<tz_ast_class::InitListExpr *>(InitExpr)) {
        LocalSymbolValueMap[name] = initValue;
        return PrevBB;
      } else {
        if (type->isArrayTy() && type->getArrayElementType() ==
                                     llvm::Type::getInt8Ty(llvm_context)) {
          // string
          assert(initValue->getType() ==
                     llvm::Type::getInt8PtrTy(llvm_context) &&
                 "string init value is not i8*");
          LocalSymbolValueMap[name] = initValue;
          return PrevBB;
        } else {
          auto &entryBlock = PrevBB->getParent()->getEntryBlock();
          if (entryBlock.getTerminator() == nullptr) {
            builder.SetInsertPoint(&entryBlock);
          } else {
            builder.SetInsertPoint(entryBlock.getTerminator());
          }
          auto alloca = builder.CreateAlloca(type, nullptr, name);
          builder.SetInsertPoint(PrevBB);
          builder.CreateStore(initValue, alloca);
          LocalSymbolValueMap[name] = alloca;
        }
      }
      return PrevBB;
    } else {
      assert(!isConst);
      if (type->isArrayTy()) {
        auto topArrayType = llvm::dyn_cast<llvm::ArrayType>(type);
        auto BasicType = topArrayType->getElementType();
        int MatrixSize = topArrayType->getNumElements() *
                         tz_ast_utils::ConvertMatToVec(BasicType);
        auto arraySize = llvm::ConstantInt::get(
            llvm::Type::getInt32Ty(llvm_context), MatrixSize);
        auto &entryBlock = PrevBB->getParent()->getEntryBlock();
        if (entryBlock.getTerminator() == nullptr) {
          builder.SetInsertPoint(&entryBlock);
        } else {
          builder.SetInsertPoint(entryBlock.getTerminator());
        }
        auto alloca = builder.CreateAlloca(BasicType, arraySize, name);
        LocalSymbolValueMap[name] = alloca;
        return PrevBB;
      } else {
        // set insert point right before the vary first instruction at the entry
        // block
        auto &entryBlock = PrevBB->getParent()->getEntryBlock();
        if (entryBlock.getTerminator() == nullptr) {
          builder.SetInsertPoint(&entryBlock);
        } else {
          builder.SetInsertPoint(entryBlock.getTerminator());
        }
        auto alloca = builder.CreateAlloca(type, nullptr, name);
        LocalSymbolValueMap[name] = alloca;
        return PrevBB;
      }
    }
  }
  // It is impossible to go here
  assert("Failure in Emitting VarDecl, Impossible flow" && false);
  return nullptr;
}
llvm::BasicBlock *tz_ast_class::ParmVarDecl::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  // Deprecated! Need to now the number of Parm, Implemented in FuncitonDecl
  auto CurrentBB = PrevBB;
  llvm::IRBuilder<> builder(CurrentBB);
  auto TheFunction = PrevBB->getParent();
  return nullptr;
}

llvm::BasicBlock *tz_ast_class::FunctionDecl::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  if (FuncStmt == nullptr) {
    // Only declaration, no implementation
    return PrevBB;
  }
  auto CastedFunctionType = llvm::dyn_cast<llvm::FunctionType>(type);
  // Sign up the function signature in module
  auto TheFunction = llvm::Function::Create(
      CastedFunctionType, llvm::Function::ExternalLinkage, name, TheModule);

  auto CurrentBB =
      llvm::BasicBlock::Create(llvm_context, "entry", TheFunction, nullptr);
  // auto returnBB =
  //     llvm::BasicBlock::Create(llvm_context, "return", TheFunction, nullptr);
  // GlobalRetBB = returnBB;

  llvm::IRBuilder<> builder(CurrentBB);
  // In the new range, clear the local symbol map
  LocalSymbolValueMap.clear();

  if (CastedFunctionType->getReturnType()->isVoidTy() == false) {
    auto retval = builder.CreateAlloca(CastedFunctionType->getReturnType(),
                                       nullptr, "retval");
    LocalSymbolValueMap["retval"] = retval;
  }

  // Initialize for funParams
  // Notice: In C Standards, we can not set default Value for params
  auto LLVMargSign = TheFunction->arg_begin();
  for (auto &Param : params) {
    LLVMargSign->setName(Param->name);
    auto alloca = builder.CreateAlloca(LLVMargSign->getType(), nullptr,
                                       LLVMargSign->getName());
    builder.CreateStore(LLVMargSign, alloca);
    LocalSymbolValueMap[Param->name] = alloca;
    ++LLVMargSign;
  }

  llvm::Value *uselessRetValue = nullptr;
  CurrentBB =
      FuncStmt->emit(TheModule, llvm_context, CurrentBB, &uselessRetValue);
  assert("FuncBody emit failure" && CurrentBB != nullptr);

  // Define the return if the function body does not contain the return
  if (builder.GetInsertBlock()->getTerminator() == nullptr) {
    // builder.CreateBr(GlobalRetBB);
    // Define the return if the function body does not contain the return
    if (builder.GetInsertBlock()->getTerminator() == nullptr) {
      if (TheFunction->getReturnType()->isVoidTy()) {
        builder.CreateRetVoid();
      } else {
        // Create return for non-void funcitons.
        builder.CreateRet(
            llvm::Constant::getNullValue(TheFunction->getReturnType()));
      }
    }
  }

  // llvm::IRBuilder<> builder_ret(returnBB);
  // if (CastedFunctionType->getReturnType()->isVoidTy()) {
  //   builder_ret.CreateRetVoid();
  // } else {
  //   auto retval = LocalSymbolValueMap["retval"];
  //   builder_ret.CreateRet(builder_ret.CreateLoad(retval));
  // }
  // For non-return at the end
  // if (CastedFunctionType->getReturnType()->isVoidTy() == false) {
  //   auto retval = builder.CreateAlloca(CastedFunctionType->getReturnType(),
  //                                      nullptr, "retval");
  //   LocalSymbolValueMap["retval"] = retval;
  // }
  llvm::verifyFunction(*TheFunction);
  // Have already sign up for the function, no need to return.
  return nullptr;
}

/********************************
 *  Stmt
 *  CompoundStmt
 *  ReturnStmt
 *  IfStmt
 *  WhileStmt
 *  DoStmt
 *  NullStmt
 *  BreakStmt
 *  ContinueStmt
 *  DeclStmt
 ********************************/

llvm::BasicBlock *tz_ast_class::CompoundStmt::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  // Traverse the stmts and return the latest BB InnerStmts
  auto LatestBB = PrevBB;
  for (auto &InnerStmt : InnerStmts) {
    llvm::Value *UselessRetValue = nullptr;
    LatestBB =
        InnerStmt->emit(TheModule, llvm_context, LatestBB, &UselessRetValue);
    assert("CompoundStmt has build a null stmt" && LatestBB != nullptr);
  }
  return LatestBB;
}
llvm::BasicBlock *tz_ast_class::ReturnStmt::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  llvm::IRBuilder<> builder(PrevBB);
  if (ReturnExpr != nullptr) {
    llvm::Value *RetValue = nullptr;
    ReturnExpr->emit(TheModule, llvm_context, PrevBB, &RetValue);
    // builder.SetInsertPoint(PrevBB);
    // auto retval = LocalSymbolValueMap["retval"];
    // builder.CreateStore(RetValue, retval);
    // builder.CreateBr(GlobalRetBB);
    builder.CreateRet(RetValue);

  } else {
    // builder.CreateBr(GlobalRetBB);
    builder.CreateRetVoid();
  }
  // Return ,so no BB is to follow
  return PrevBB;
}
llvm::BasicBlock *tz_ast_class::IfStmt::emit(llvm::Module &TheModule,
                                             llvm::LLVMContext &llvm_context,
                                             llvm::BasicBlock *PrevBB,
                                             llvm::Value **ReturnValue) {
  bool TerminateAtThen = false;
  bool TerminateAtElse = false;
  auto CurrentParentFunction = PrevBB->getParent();

  auto ifthenBB =
      llvm::BasicBlock::Create(llvm_context, "ifThen", CurrentParentFunction);
  auto ifendBB = llvm::BasicBlock::Create(llvm_context, "ifEnd", nullptr);

  // Handle the Condtion
  llvm::IRBuilder<> builder_cond(PrevBB);
  llvm::Value *CondValue = nullptr;
  PrevBB = IfCondExpr->emit(TheModule, llvm_context, PrevBB, &CondValue);
  builder_cond.SetInsertPoint(PrevBB);

  // Check Condition Value
  auto type = CondValue->getType();
  if (type->isIntegerTy(1)) {
    // Bool
    CondValue = CondValue;
  } else if (type->isIntegerTy()) {
    // Interger
    CondValue =
        builder_cond.CreateICmpNE(CondValue, llvm::ConstantInt::get(type, 0));
  } else if (type->isFloatingPointTy()) {
    // Float
    CondValue =
        builder_cond.CreateFCmpONE(CondValue, llvm::ConstantFP::get(type, 0));
  } else {
    assert("Wrong Condition Type" && false);
  }

  if (hasElse) {
    auto ifelseBB =
        llvm::BasicBlock::Create(llvm_context, "ifElse", CurrentParentFunction);

    // Short_Circut Handle:
    builder_cond.CreateCondBr(CondValue, ifthenBB, ifelseBB);

    // Handle ifthen
    llvm::IRBuilder<> builder_ifthen(ifthenBB);
    llvm::Value *useless_retvalue = nullptr;
    ifthenBB =
        ThenObj->emit(TheModule, llvm_context, ifthenBB, &useless_retvalue);

    // Finished! TODO(To be simplified): Fix terminator stuff
    //  && ifthenBB->getTerminator() == nullptr
    if (ifthenBB != nullptr && ifthenBB->getTerminator() == nullptr) {
      if (ifendBB->getParent() == nullptr) {
        ifendBB->insertInto(CurrentParentFunction);
        ifelseBB->moveBefore(ifendBB);
      }
      builder_ifthen.SetInsertPoint(ifthenBB);
      builder_ifthen.CreateBr(ifendBB);
      TerminateAtThen = true;
    }

    // Handle ifelse
    llvm::IRBuilder<> builder_ifelse(ifelseBB);
    useless_retvalue = nullptr;
    ifelseBB =
        ElseObj->emit(TheModule, llvm_context, ifelseBB, &useless_retvalue);
    // &&ifelseBB->getTerminator() == nullptr
    if (ifelseBB != nullptr && ifelseBB->getTerminator() == nullptr) {
      if (ifendBB->getParent() == nullptr) {
        ifendBB->insertInto(CurrentParentFunction);
        ifelseBB->moveBefore(ifendBB);
      }
      builder_ifelse.SetInsertPoint(ifelseBB);
      builder_ifelse.CreateBr(ifendBB);
      TerminateAtElse = true;
    }
    if (!TerminateAtThen && !TerminateAtElse) {
      return PrevBB;
    } else {
      return ifendBB;
    }
  } else {
    builder_cond.CreateCondBr(CondValue, ifthenBB, ifendBB);
    ifendBB->insertInto(CurrentParentFunction);

    // Handle ifthen
    llvm::IRBuilder<> builder_ifthen(ifthenBB);
    llvm::Value *useless_retvalue = nullptr;
    ifthenBB =
        ThenObj->emit(TheModule, llvm_context, ifthenBB, &useless_retvalue);
    //  && ifthenBB->getTerminator() == nullptr
    if (ifthenBB != nullptr && ifthenBB->getTerminator() == nullptr) {
      builder_ifthen.SetInsertPoint(ifthenBB);
      builder_ifthen.CreateBr(ifendBB);
    }

    return ifendBB;
  }
}
llvm::BasicBlock *tz_ast_class::WhileStmt::emit(llvm::Module &TheModule,
                                                llvm::LLVMContext &llvm_context,
                                                llvm::BasicBlock *PrevBB,
                                                llvm::Value **ReturnValue) {
  auto CurrentParentFunction = PrevBB->getParent();

  // While is a loop structure, we need to maintain the jump relation
  llvm::BasicBlock *WhileCondBeginBB = llvm::BasicBlock::Create(
      llvm_context, "whileCond", CurrentParentFunction);
  llvm::BasicBlock *WhileCondEndBB = WhileCondBeginBB;
  llvm::BasicBlock *WhileBodyBeginBB = llvm::BasicBlock::Create(
      llvm_context, "whileBody", CurrentParentFunction);
  llvm::BasicBlock *WhileBodyEndBB = WhileBodyBeginBB;
  llvm::BasicBlock *WhileEndBB =
      llvm::BasicBlock::Create(llvm_context, "whileEnd", CurrentParentFunction);

  // Maintain the stack
  WhileStack.push_back(
      tz_ast_utils::WhileRangeControl(WhileCondBeginBB, WhileEndBB));

  // Handle the Condtion
  llvm::IRBuilder<> builder_cond_begin(PrevBB);
  builder_cond_begin.CreateBr(WhileCondBeginBB);

  llvm::IRBuilder<> builder_cond(WhileCondEndBB);
  llvm::Value *CondValue = nullptr;
  WhileCondEndBB =
      WhileCondExpr->emit(TheModule, llvm_context, WhileCondEndBB, &CondValue);
  builder_cond.SetInsertPoint(WhileCondEndBB);

  // Check Condition Value
  auto type = CondValue->getType();
  if (type->isIntegerTy(1)) {
    // Bool
    CondValue = CondValue;
  } else if (type->isIntegerTy()) {
    // Interger
    CondValue =
        builder_cond.CreateICmpNE(CondValue, llvm::ConstantInt::get(type, 0));
  } else if (type->isFloatingPointTy()) {
    // Float
    CondValue =
        builder_cond.CreateFCmpONE(CondValue, llvm::ConstantFP::get(type, 0));
  } else {
    assert("Wrong Condition Type" && false);
  }
  // May be finished. TODO(the flow to be checked)! may be wrong.
  builder_cond.CreateCondBr(CondValue, WhileBodyBeginBB, WhileEndBB);

  // Handle the body
  llvm::IRBuilder<> builder_whilebody(WhileBodyEndBB);
  llvm::Value *useless_retvalue = nullptr;
  WhileBodyEndBB = WhileObj->emit(TheModule, llvm_context, WhileBodyEndBB,
                                  &useless_retvalue);
  // Maintain the terminate relationship
  if (WhileBodyEndBB != nullptr && WhileBodyEndBB->getTerminator() == nullptr) {
    builder_whilebody.SetInsertPoint(WhileBodyEndBB);
    builder_whilebody.CreateBr(WhileCondBeginBB);
  }

  WhileStack.pop_back();

  return WhileEndBB;
}
llvm::BasicBlock *tz_ast_class::DoStmt::emit(llvm::Module &TheModule,
                                             llvm::LLVMContext &llvm_context,
                                             llvm::BasicBlock *PrevBB,
                                             llvm::Value **ReturnValue) {
  // Totally the same as while
  auto CurrentParentFunction = PrevBB->getParent();

  // Do is a loop structure, we need to maintain the jump relation
  llvm::BasicBlock *DoCondBeginBB =
      llvm::BasicBlock::Create(llvm_context, "doCond", CurrentParentFunction);
  llvm::BasicBlock *DoCondEndBB = DoCondBeginBB;
  llvm::BasicBlock *DoBodyBeginBB =
      llvm::BasicBlock::Create(llvm_context, "doBody", CurrentParentFunction);
  llvm::BasicBlock *DoBodyEndBB = DoBodyBeginBB;
  llvm::BasicBlock *DoEndBB =
      llvm::BasicBlock::Create(llvm_context, "doEnd", CurrentParentFunction);

  // Maintain the stack
  WhileStack.push_back(tz_ast_utils::WhileRangeControl(DoCondBeginBB, DoEndBB));

  // Handle the Condtion
  llvm::IRBuilder<> builder_cond_begin(PrevBB);
  builder_cond_begin.CreateBr(DoCondBeginBB);

  llvm::IRBuilder<> builder_cond(DoCondEndBB);
  llvm::Value *CondValue = nullptr;
  DoCondEndBB =
      DoCondExpr->emit(TheModule, llvm_context, DoCondEndBB, &CondValue);
  builder_cond.SetInsertPoint(DoCondEndBB);

  // Check Condition Value
  auto type = CondValue->getType();
  if (type->isIntegerTy(1)) {
    // Bool
    CondValue = CondValue;
  } else if (type->isIntegerTy()) {
    // Interger
    CondValue =
        builder_cond.CreateICmpNE(CondValue, llvm::ConstantInt::get(type, 0));
  } else if (type->isFloatingPointTy()) {
    // Float
    CondValue =
        builder_cond.CreateFCmpONE(CondValue, llvm::ConstantFP::get(type, 0));
  } else {
    assert("Wrong Condition Type" && false);
  }
  // May be finished. TODO(the flow to be checked)! may be wrong.
  builder_cond.CreateCondBr(CondValue, DoBodyBeginBB, DoEndBB);

  // Handle the body
  llvm::IRBuilder<> builder_whilebody(DoBodyEndBB);
  llvm::Value *useless_retvalue = nullptr;
  DoBodyEndBB =
      DoObj->emit(TheModule, llvm_context, DoBodyEndBB, &useless_retvalue);
  // Maintain the terminate relationship
  if (DoBodyEndBB != nullptr && DoBodyEndBB->getTerminator() == nullptr) {
    builder_whilebody.SetInsertPoint(DoBodyEndBB);
    builder_whilebody.CreateBr(DoCondBeginBB);
  }

  WhileStack.pop_back();

  return DoEndBB;
}
llvm::BasicBlock *tz_ast_class::NullStmt::emit(llvm::Module &TheModule,
                                               llvm::LLVMContext &llvm_context,
                                               llvm::BasicBlock *PrevBB,
                                               llvm::Value **ReturnValue) {
  // Do nothing
  return PrevBB;
}
llvm::BasicBlock *tz_ast_class::BreakStmt::emit(llvm::Module &TheModule,
                                                llvm::LLVMContext &llvm_context,
                                                llvm::BasicBlock *PrevBB,
                                                llvm::Value **ReturnValue) {
  llvm::IRBuilder<> builder(PrevBB);
  assert("No while! While Contorl Range Failure." && WhileStack.size() > 0);
  auto &whileEnd = WhileStack.back().whileEnd;
  builder.CreateBr(whileEnd);
  // PrevBB->moveBefore(whileEndStak.back());
  return PrevBB;
}
llvm::BasicBlock *tz_ast_class::ContinueStmt::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  llvm::IRBuilder<> builder(PrevBB);
  assert("No while! While Contorl Range Failure." && WhileStack.size() > 0);
  auto &whileEnd = WhileStack.back().whileBegin;
  builder.CreateBr(whileEnd);
  // PrevBB->moveBefore(whileEndStak.back());
  return PrevBB;
}
llvm::BasicBlock *tz_ast_class::DeclStmt::emit(llvm::Module &TheModule,
                                               llvm::LLVMContext &llvm_context,
                                               llvm::BasicBlock *PrevBB,
                                               llvm::Value **ReturnValue) {
  auto CurrentBB = PrevBB;
  if (Decls.size()) {
    for (auto &Decl : Decls) {
      assert("Decl in Decls is Null!" && Decl != nullptr);
      CurrentBB = Decl->emit(TheModule, llvm_context, CurrentBB, nullptr);
    }
  }
  return CurrentBB;
}