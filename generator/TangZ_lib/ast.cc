#include "ast.h"

#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Type.h>
#include <llvm/Support/JSON.h>

#include <cassert>
#include <cstdio>
#include <string>
#include <utility>

#include "llvm/ADT/APFloat.h"
#include "llvm/ADT/APInt.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Value.h"

// Use the map and the unique id generated by llvm to find all the ast nodes.
std::map<std::string, tz_ast_class::Object *> GlobalSymbolAstMap;

#define DEBUG
/********************************
 * Constructors of all the AST nodes in tz_ast_class
 ********************************/

/********************************
 *  Expr
 *  Literal: IntegerLiteral, FloatingLiteral, StringLiteral
 *  BinaryExpr
 *  UnaryExpr
 *  CallExpr
 *  DeclRefExpr
 *  ImplicitCastExpr
 *  InitListExpr
 *  ArraySubscriptExpr
 ********************************/
tz_ast_class::IntegerLiteral::IntegerLiteral(
    llvm::LLVMContext &llvm_context, const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("IntegerLiteral\n");
#endif
  // IntegerLiteral May be int or long or longlong
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get value
  if (type->isIntegerTy(32)) {
    // int
    value = llvm::ConstantInt::get(
        llvm::Type::getInt32Ty(llvm_context),
        llvm::APInt(type->getIntegerBitWidth(),
                    json_tree->getString("value")->str(), 10));
  } else if (type->isIntegerTy(64)) {
    // long long
    value = llvm::ConstantInt::get(
        llvm::Type::getInt64Ty(llvm_context),
        llvm::APInt(type->getIntegerBitWidth(),
                    json_tree->getString("value")->str(), 10));
  } else {
    assert("IntegerLiteral Initialization False" && false);
  }
}

tz_ast_class::FloatingLiteral::FloatingLiteral(
    llvm::LLVMContext &llvm_context, const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("FloatingLiteral\n");
#endif
  // FloatingLiteral May be float or double
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get value
  if (type->isFloatTy()) {
    // float
    value = llvm::ConstantFP::get(
        llvm::Type::getFloatTy(llvm_context),
        llvm::APFloat(llvm::APFloatBase().IEEEsingle(),
                      json_tree->getString("value")->str()));
  } else if (type->isDoubleTy()) {
    value = llvm::ConstantFP::get(
        llvm::Type::getDoubleTy(llvm_context),
        llvm::APFloat(llvm::APFloatBase().IEEEdouble(),
                      json_tree->getString("value")->str()));
  } else {
    assert("FloatingLiteral Initialization False" && false);
  }
}

tz_ast_class::StringLiteral::StringLiteral(
    llvm::LLVMContext &llvm_context, const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("StringLiteral\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  std::string _value = json_tree->getString("value")->str();
  // remove the " at the head and tail
  _value = _value.substr(1, _value.size() - 2);
  // Finished! TODO(Need to process stupid chars): May be wrong!
  _value = tz_ast_utils::Unescape(_value);
  while (_value.size() < type->getArrayNumElements()) {
    _value += '\0';
  }
  assert("Unescaped value string is as long as length defined by type" &&
         _value.size() == type->getArrayNumElements());
  if (type->isArrayTy()) {
    // array
    // disable a null terminator added
    value = llvm::ConstantDataArray::getString(llvm_context, _value, false);
  } else {
    assert("FloatingLiteral Initialization False" && false);
  }
}

tz_ast_class::BinaryExpr::BinaryExpr(llvm::LLVMContext &llvm_context,
                                     const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("BinaryExpr\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get op
  std::string BinaryOPString = json_tree->getString("opcode")->str();
  op = tz_ast_utils::ParsingBinaryOp(BinaryOPString);

  // Get lhs and rhs
  auto lhs_json = (*json_tree->getArray("inner"))[0].getAsObject();
  auto rhs_json = (*json_tree->getArray("inner"))[1].getAsObject();

  lhs = dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, lhs_json));
  rhs = dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, rhs_json));
}

tz_ast_class::UnaryExpr::UnaryExpr(llvm::LLVMContext &llvm_context,
                                   const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("UnaryExpr\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get op
  std::string UnaryOPString = json_tree->getString("opcode")->str();
  op = tz_ast_utils::ParsingUnaryOp(UnaryOPString);

  // Get rhs
  auto rhs_json = (*json_tree->getArray("inner"))[0].getAsObject();
  rhs = dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, rhs_json));
}

tz_ast_class::DeclRefExpr::DeclRefExpr(llvm::LLVMContext &llvm_context,
                                       const llvm::json::Object *json_tree) {
  /******
   * All the reference will go to here,
        * including the reference to the global
        ,local,parameter and FUNCTIONS!!!
        IT IS VITAL to considerate the Feferee findings
   ******/
  // Initialize the ExprCatgry
#ifdef DEBUG
  printf("DeclRefExpr\n");
#endif
  ExprCatgry = tz_ast_type::lvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  _type = _type.substr(0, _type.find('('));
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get DeclRefee
  auto DeclRefee_ID =
      json_tree->getObject("referencedDecl")->getString("id")->str();
  // Finished! TODO(to be finished): Think of the global map strategy
  DeclRefee = dynamic_cast<Decl *>(GlobalSymbolAstMap[DeclRefee_ID]);
}

tz_ast_class::ImplicitCastExpr::ImplicitCastExpr(
    llvm::LLVMContext &llvm_context, const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("ImplicitCastExpr\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get CastCatgry
  std::string CastOPString = json_tree->getString("castKind")->str();
  CastCatgry = tz_ast_utils::ParsingImplicitCast(CastOPString);

  // Get castExpr
  auto castExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
  castExpr =
      dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, castExpr_json));
}

tz_ast_class::InitListExpr::InitListExpr(llvm::LLVMContext &llvm_context,
                                         const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("InitListExpr\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);
  // Get initExprs
  auto initExprs_json = json_tree->getArray("inner");
  if (initExprs_json == nullptr) {
    initExprs_json = json_tree->getArray("array_filler");
  }
  // Get isInited
  isInited = false;
  for (auto &initExpr_json : *initExprs_json) {
    if (initExpr_json == initExprs_json->front() &&
        initExpr_json.getAsObject()->getString("kind")->str() ==
            "ImplicitValueInitExpr") {
      // Check Whether the element is inited
      isInited = true;
      continue;
    }
    initExprs.push_back(dynamic_cast<Expr *>(
        tz_ast_utils::BuildAST(llvm_context, initExpr_json.getAsObject())));
  }
}

tz_ast_class::ArraySubscriptExpr::ArraySubscriptExpr(
    llvm::LLVMContext &llvm_context, const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("ArraySubscriptExpr\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::lvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get ArrayBase
  auto ArrayBase_json = (*json_tree->getArray("inner"))[0].getAsObject();
  ArrayBase = dynamic_cast<Expr *>(
      tz_ast_utils::BuildAST(llvm_context, ArrayBase_json));

  assert("ArraySubscriptExpr: ArrayBase is null!" && ArrayBase != nullptr);
  // Get ArrayIdx
  auto ArrayIdx_json = (*json_tree->getArray("inner"))[1].getAsObject();
  ArrayIdx =
      dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, ArrayIdx_json));
  assert("ArraySubscriptExpr: ArrayIdx is null!" && ArrayIdx != nullptr);
}

tz_ast_class::CallExpr::CallExpr(llvm::LLVMContext &llvm_context,
                                 const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("CallExpr\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get callee
  auto callee_json = (*json_tree->getArray("inner"))[0].getAsObject();
  callee =
      dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, callee_json));

  // Get CalleeArgs
  auto CalleeArgs_json = json_tree->getArray("inner");
  for (auto &CalleeArg_json : *CalleeArgs_json) {
    if (CalleeArg_json == CalleeArgs_json->front()) {
      // Jump the callee
      continue;
    }
    CalleeArgs.push_back(dynamic_cast<Expr *>(
        tz_ast_utils::BuildAST(llvm_context, CalleeArg_json.getAsObject())));
  }
}

tz_ast_class::ParenExpr::ParenExpr(llvm::LLVMContext &llvm_context,
                                   const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("ParenExpr\n");
#endif
  // Initialize the ExprCatgry
  ExprCatgry = tz_ast_type::rvalue;

  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get parenExpr
  auto parenExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
  inParenExpr = dynamic_cast<Expr *>(
      tz_ast_utils::BuildAST(llvm_context, parenExpr_json));
}

/********************************
 *  Decl
 *  TranslationUnitDecl
 *  VarDecl
 *  ParmVarDecl
 *  FunctionDecl
 ********************************/
tz_ast_class::TranslationUnitDecl::TranslationUnitDecl(
    llvm::LLVMContext &llvm_context, const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("TranslationUnitDecl\n");
#endif
  // No Name and type for TranslationUnitDecl
  type = nullptr;
  name = "";
  auto decls_json = json_tree->getArray("inner");
  for (auto &decl_json : *decls_json) {
    auto isGlobalVarDecl = false;
    if (decl_json.getAsObject()->getString("kind")->str() == "VarDecl") {
      isGlobalVarDecl = true;
    }
    Decls.push_back(dynamic_cast<Decl *>(tz_ast_utils::BuildAST(
        llvm_context, decl_json.getAsObject(), isGlobalVarDecl)));
    if (Decls.size() && Decls.back() == nullptr) {
      Decls.pop_back();
      assert("Building TranslationUnitDecl Failure: nullptr in the Decls" &&
             Decls.back() != nullptr);
    }
  }
}

tz_ast_class::VarDecl::VarDecl(llvm::LLVMContext &llvm_context,
                               const llvm::json::Object *json_tree,
                               const bool _isGlobal) {
#ifdef DEBUG
  printf("VarDecl\n");
#endif
  std::string VarDeclID = json_tree->getString("id")->str();
  // Find out whether the varDecl is global
  isGlobal = _isGlobal;
  // By default, the Var is not a const
  isConst = false;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    isConst = true;
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get name(unique)
  name = json_tree->getString("name")->str() + VarDeclID;

  // Get initExpr
  isInited = false;
  if (json_tree->get("inner") != nullptr) {
    isInited = true;
    auto initExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
    InitExpr = dynamic_cast<Expr *>(
        tz_ast_utils::BuildAST(llvm_context, initExpr_json));
  }

  // Store in the global map
  assert("Duplicate ID, already in Map!" &&
         GlobalSymbolAstMap.find(VarDeclID) == GlobalSymbolAstMap.end());
  GlobalSymbolAstMap[VarDeclID] = this;
}

tz_ast_class::ParmVarDecl::ParmVarDecl(llvm::LLVMContext &llvm_context,
                                       const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("ParmVarDecl\n");
#endif
  std::string ParamVarDeclID = json_tree->getString("id")->str();
  // By default, the Var is not a const
  isConst = false;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    isConst = true;
    _type = _type.substr(6, _type.size() - 1);
  }
  type = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get name (unique)
  name = json_tree->getString("name")->str() + ParamVarDeclID;

  // Get initExpr
  isInited = false;
  if (json_tree->getObject("inner") != nullptr) {
    isInited = true;
    auto initExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
    InitExpr = dynamic_cast<Expr *>(
        tz_ast_utils::BuildAST(llvm_context, initExpr_json));
  }

  // Store in the global map
  assert("Duplicate ID, already in Map!" &&
         GlobalSymbolAstMap.find(ParamVarDeclID) == GlobalSymbolAstMap.end());
  GlobalSymbolAstMap[ParamVarDeclID] = this;
}

tz_ast_class::FunctionDecl::FunctionDecl(llvm::LLVMContext &llvm_context,
                                         const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("FunctionDecl\n");
#endif
  // Get the unique ID for reference
  std::string FuncDeclID = json_tree->getString("id")->str();
  // Judege whether the numebr of params is dynamic
  isVariadic = false;
  if (json_tree->get("isVariadic") != nullptr) {
    isVariadic = true;
  }
  if (json_tree->get("storageClass") != nullptr &&
      json_tree->getString("storageClass")->str() == "extern") {
    // No need to process the external functions
    isExternal = true;
    return;
  }
  isExternal = false;
  // By default, the Var is not a const
  isConst = false;
  // Get type
  auto _type = json_tree->getObject("type")->getString("qualType")->str();
  // Just want to get the return type.
  _type = _type.substr(0, _type.find('('));
  if (_type.find("const") != std::string::npos) {
    // remove the const description
    isConst = true;
    _type = _type.substr(6, _type.size() - 1);
  }
  ReturnType = tz_ast_utils::ParsingLLVMType(llvm_context, _type);

  // Get name (unique)
  name = json_tree->getString("name")->str() + FuncDeclID;

  // TODO(unknown): Finish the following parts
  auto ParmVarDeclsWithBody_json = json_tree->getArray("inner");
  if (ParmVarDeclsWithBody_json == nullptr) {
    // the function has no params and no body.
    assert("Duplicate ID, already in Map!" &&
           GlobalSymbolAstMap.find(FuncDeclID) == GlobalSymbolAstMap.end());
    GlobalSymbolAstMap[FuncDeclID] = this;
  }
  // Get ParmVarDecls
  std::vector<llvm::Type *> ParamTypes;
  for (auto &ParmVarDecl_json : *ParmVarDeclsWithBody_json) {
    if (ParmVarDecl_json.getAsObject()->getString("kind")->str() ==
        "CompoundStmt") {
      break;
    }
    ParmVarDecl *ParamDecl = dynamic_cast<ParmVarDecl *>(
        tz_ast_utils::BuildAST(llvm_context, ParmVarDecl_json.getAsObject()));
    assert("Building FuncDecl Failure: ParamVarDecl wrong!" &&
           ParamDecl != nullptr);
    ParamTypes.push_back(ParamDecl->type);
    // params.push_back(dynamic_cast<Decl *>(ParamDecl));
    params.push_back(ParamDecl);
  }

  type = llvm::FunctionType::get(ReturnType, ParamTypes, isVariadic);

  // Get body
  auto body_json = json_tree->getArray("inner")->back().getAsObject();
  FuncStmt = dynamic_cast<CompoundStmt *>(
      tz_ast_utils::BuildAST(llvm_context, body_json));

  // Store in the global map
  assert("Duplicate ID, already in Map!" &&
         GlobalSymbolAstMap.find(FuncDeclID) == GlobalSymbolAstMap.end());
  GlobalSymbolAstMap[FuncDeclID] = this;
}

/********************************
 *  Stmt
 *  CompoundStmt
 *  ReturnStmt
 *  IfStmt
 *  WhileStmt
 *  DoStmt
 *  NullStmt
 *  BreakStmt
 *  ContinueStmt
 *  DeclStmt
 ********************************/

tz_ast_class::CompoundStmt::CompoundStmt(llvm::LLVMContext &llvm_context,
                                         const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("CompoundStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::Compound;
  // Get Stmts
  auto Stmts_json = json_tree->getArray("inner");
  if (Stmts_json != nullptr) {
    for (auto &Stmt_json : *Stmts_json) {
      auto Stmt_to_be_add =
          tz_ast_utils::BuildAST(llvm_context, Stmt_json.getAsObject());
      InnerStmts.push_back(Stmt_to_be_add);
      if (InnerStmts.size() && typeid(*Stmt_to_be_add) == typeid(ReturnStmt)) {
        break;
      }
    }
  }
}

tz_ast_class::ReturnStmt::ReturnStmt(llvm::LLVMContext &llvm_context,
                                     const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("ReturnStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::Return;
  // Get returnExpr
  ReturnExpr = nullptr;
  if (json_tree->getObject("inner") == nullptr) {
    auto returnExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
    ReturnExpr = dynamic_cast<Expr *>(
        tz_ast_utils::BuildAST(llvm_context, returnExpr_json));
  }
}

tz_ast_class::IfStmt::IfStmt(llvm::LLVMContext &llvm_context,
                             const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("IfStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::If;
  // Get condExpr
  auto condExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
  IfCondExpr =
      dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, condExpr_json));
  // Get thenStmt
  auto thenStmt_json = (*json_tree->getArray("inner"))[1].getAsObject();
  ThenObj = dynamic_cast<Object *>(
      tz_ast_utils::BuildAST(llvm_context, thenStmt_json));
  assert(ThenObj != nullptr && "Then Obj of IFstmt is null!");
  // Get elseStmt
  hasElse = false;
  if (json_tree->getArray("inner")->size() == 3) {
    hasElse = true;
    auto elseStmt_json = (*json_tree->getArray("inner"))[2].getAsObject();
    ElseObj = dynamic_cast<Object *>(
        tz_ast_utils::BuildAST(llvm_context, elseStmt_json));
    assert(ElseObj != nullptr && "Then else of IFstmt is null!");
  }
}

tz_ast_class::WhileStmt::WhileStmt(llvm::LLVMContext &llvm_context,
                                   const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("WhileStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::While;
  // Get condExpr
  auto condExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
  WhileCondExpr =
      dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, condExpr_json));
  assert("While Cond is Null" && WhileObj != nullptr);
  // Get body
  auto body_json = (*json_tree->getArray("inner"))[1].getAsObject();
  WhileObj =
      dynamic_cast<Stmt *>(tz_ast_utils::BuildAST(llvm_context, body_json));
  assert("Error: While has no body!" && WhileObj != nullptr);
}

tz_ast_class::DoStmt::DoStmt(llvm::LLVMContext &llvm_context,
                             const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("DoStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::While;
  // Get DoCondExpr
  auto condExpr_json = (*json_tree->getArray("inner"))[0].getAsObject();
  DoCondExpr =
      dynamic_cast<Expr *>(tz_ast_utils::BuildAST(llvm_context, condExpr_json));
  // Get body
  auto body_json = (*json_tree->getArray("inner"))[1].getAsObject();
  DoObj = dynamic_cast<Stmt *>(tz_ast_utils::BuildAST(llvm_context, body_json));
  assert("Error: Do has no body!" && DoObj != nullptr);
}

tz_ast_class::NullStmt::NullStmt(llvm::LLVMContext &llvm_context,
                                 const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("NullStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::Null;
  // Nothing else to do
}

tz_ast_class::BreakStmt::BreakStmt(llvm::LLVMContext &llvm_context,
                                   const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("BreakStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::Break;
  // Nothing else to do
}

tz_ast_class::ContinueStmt::ContinueStmt(llvm::LLVMContext &llvm_context,
                                         const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("ContinueStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::Continue;
  // Nothing else to do
}

tz_ast_class::DeclStmt::DeclStmt(llvm::LLVMContext &llvm_context,
                                 const llvm::json::Object *json_tree) {
#ifdef DEBUG
  printf("DeclStmt\n");
#endif
  // Initialize the StmtCatgry
  StmtCatgry = tz_ast_type::Decl;
  // Get Decls
  auto Decls_json = json_tree->getArray("inner");
  for (auto &Decl_json : *Decls_json) {
    Decls.push_back(dynamic_cast<Decl *>(
        tz_ast_utils::BuildAST(llvm_context, Decl_json.getAsObject())));
  }
}

/********************************
 * Utils implementation
 ********************************/
tz_ast_class::Object *tz_ast_utils::BuildAST(
    llvm::LLVMContext &llvm_context, const llvm::json::Object *json_tree,
    const bool isGlobal) {
  // Remember to assert when there is no-matched kind
  std::string NodeKind = json_tree->getString("kind")->str();
  if (NodeKind == "IntegerLiteral") {
    return new tz_ast_class::IntegerLiteral(llvm_context, json_tree);
  } else if (NodeKind == "FloatingLiteral") {
    return new tz_ast_class::FloatingLiteral(llvm_context, json_tree);
  } else if (NodeKind == "StringLiteral") {
    return new tz_ast_class::StringLiteral(llvm_context, json_tree);
  } else if (NodeKind == "BinaryOperator") {
    return new tz_ast_class::BinaryExpr(llvm_context, json_tree);
  } else if (NodeKind == "UnaryOperator") {
    return new tz_ast_class::UnaryExpr(llvm_context, json_tree);
  } else if (NodeKind == "CallExpr") {
    return new tz_ast_class::CallExpr(llvm_context, json_tree);
  } else if (NodeKind == "DeclRefExpr") {
    return new tz_ast_class::DeclRefExpr(llvm_context, json_tree);
  } else if (NodeKind == "ImplicitCastExpr") {
    return new tz_ast_class::ImplicitCastExpr(llvm_context, json_tree);
  } else if (NodeKind == "InitListExpr") {
    return new tz_ast_class::InitListExpr(llvm_context, json_tree);
  } else if (NodeKind == "ArraySubscriptExpr") {
    return new tz_ast_class::ArraySubscriptExpr(llvm_context, json_tree);
  } else if (NodeKind == "ParenExpr") {
    return new tz_ast_class::ParenExpr(llvm_context, json_tree);
  } else if (NodeKind == "TranslationUnitDecl") {
    return new tz_ast_class::TranslationUnitDecl(llvm_context, json_tree);
  } else if (NodeKind == "VarDecl") {
    return new tz_ast_class::VarDecl(llvm_context, json_tree, isGlobal);
  } else if (NodeKind == "ParmVarDecl") {
    return new tz_ast_class::ParmVarDecl(llvm_context, json_tree);
  } else if (NodeKind == "FunctionDecl") {
    return new tz_ast_class::FunctionDecl(llvm_context, json_tree);
  } else if (NodeKind == "CompoundStmt") {
    return new tz_ast_class::CompoundStmt(llvm_context, json_tree);
  } else if (NodeKind == "ReturnStmt") {
    return new tz_ast_class::ReturnStmt(llvm_context, json_tree);
  } else if (NodeKind == "IfStmt") {
    return new tz_ast_class::IfStmt(llvm_context, json_tree);
  } else if (NodeKind == "WhileStmt") {
    return new tz_ast_class::WhileStmt(llvm_context, json_tree);
  } else if (NodeKind == "DoStmt") {
    return new tz_ast_class::DoStmt(llvm_context, json_tree);
  } else if (NodeKind == "NullStmt") {
    return new tz_ast_class::NullStmt(llvm_context, json_tree);
  } else if (NodeKind == "BreakStmt") {
    return new tz_ast_class::BreakStmt(llvm_context, json_tree);
  } else if (NodeKind == "ContinueStmt") {
    return new tz_ast_class::ContinueStmt(llvm_context, json_tree);
  } else if (NodeKind == "DeclStmt") {
    return new tz_ast_class::DeclStmt(llvm_context, json_tree);
  } else if (NodeKind == "TypedefDecl" || NodeKind == "array_filler") {
    return nullptr;
    // TODO(nullptr judgement): May be wrong;
  } else {
    printf("Current kind is %s\n", NodeKind.c_str());
    assert("BuildAST False, Wrong Json Kind" && false);
  }
}

std::string tz_ast_utils::StripTailChars(const std::string str, const char c) {
  int none_C_idx = str.size() - 1;
  while (str[none_C_idx] == ' ') {
    none_C_idx--;
  }
  ++none_C_idx;
  return str.substr(0, none_C_idx);
}
llvm::Type *tz_ast_utils::ParsingLLVMType(llvm::LLVMContext &llvm_context,
                                          std::string str) {
  // Notice: InitList is pretty hard
  //        Function Name and Array type is the most complicated

  str = StripTailChars(str, ' ');
#ifdef DEBUG
  // printf("ParsingLLVMType: %s\n", str.c_str());
#endif
  if (str == "void") {
    return llvm::Type::getVoidTy(llvm_context);
  } else if (str == "char") {
    return llvm::Type::getInt8Ty(llvm_context);
  } else if (str == "short") {
    return llvm::Type::getInt16Ty(llvm_context);
  } else if (str == "int" || str == "unsigned int") {
    return llvm::Type::getInt32Ty(llvm_context);
  } else if (str == "long" || str == "unsigned long") {
    return llvm::Type::getInt32PtrTy(llvm_context);
  } else if (str == "long long") {
    return llvm::Type::getInt64PtrTy(llvm_context);
  } else if (str == "float") {
    return llvm::Type::getFloatTy(llvm_context);
  } else if (str == "double") {
    return llvm::Type::getDoubleTy(llvm_context);
  } else if (str.find('[') != str.npos) {
    auto pos = str.find('[');
    // Get the int [3] 's 3
    auto ArraySizeStr = str.substr(pos + 1, str.find_first_of(']') - pos - 1);
    auto ArraySize = std::stoi(ArraySizeStr);
    // Remove the [3]
    str.replace(pos, str.find_first_of(']') - pos + 1, "");
    return llvm::ArrayType::get(ParsingLLVMType(llvm_context, str), ArraySize);
  } else if (str.find('*') != str.npos) {
    // Parsing type like int * & int (*)()
    auto pos = str.find("(*)");
    if (pos == str.npos) {
      // it is int *
      pos = str.find('*');
    }
    // remove the tailing * or (*)
    str = str.substr(0, pos);
    // get the type of array
    return llvm::PointerType::get(ParsingLLVMType(llvm_context, str), 0);
  } else {
    printf("ParsingLLVMType: %s\n", str.c_str());
    assert("ParsingLLVMType False" && false);
  }
}

tz_ast_type::BinaryOpCatgry tz_ast_utils::ParsingBinaryOp(std::string str) {
  if (str == "+") {
    return tz_ast_type::BinaryOpCatgry::Add;
  } else if (str == "-") {
    return tz_ast_type::BinaryOpCatgry::Sub;
  } else if (str == "*") {
    return tz_ast_type::BinaryOpCatgry::Mul;
  } else if (str == "/") {
    return tz_ast_type::BinaryOpCatgry::Div;
  } else if (str == "%") {
    return tz_ast_type::BinaryOpCatgry::Mod;
  } else if (str == "<") {
    return tz_ast_type::BinaryOpCatgry::Less;
  } else if (str == "<=") {
    return tz_ast_type::BinaryOpCatgry::LessEq;
  } else if (str == ">") {
    return tz_ast_type::BinaryOpCatgry::Greater;
  } else if (str == ">=") {
    return tz_ast_type::BinaryOpCatgry::GreaterEq;
  } else if (str == "=") {
    return tz_ast_type::BinaryOpCatgry::Eq;
  } else if (str == "==") {
    return tz_ast_type::BinaryOpCatgry::EqEq;
  } else if (str == "!=") {
    return tz_ast_type::BinaryOpCatgry::ExclaimEq;
  } else if (str == "&&") {
    return tz_ast_type::BinaryOpCatgry::AmpAmp;
  } else if (str == "||") {
    return tz_ast_type::BinaryOpCatgry::PipePipe;
  } else {
    assert("ParsingBinaryOp False" && false);
  }
}
tz_ast_type::UnaryOpCatgry tz_ast_utils::ParsingUnaryOp(std::string str) {
  if (str == "&") {
    return tz_ast_type::UnaryOpCatgry::U_FindAddr;
  } else if (str == "*") {
    return tz_ast_type::UnaryOpCatgry::U_Deref;
  } else if (str == "+") {
    return tz_ast_type::UnaryOpCatgry::U_Plus;
  } else if (str == "-") {
    return tz_ast_type::UnaryOpCatgry::U_Minus;
  } else if (str == "~") {
    return tz_ast_type::UnaryOpCatgry::U_Tilde;
  } else if (str == "!") {
    return tz_ast_type::UnaryOpCatgry::U_N;
  } else {
    assert("ParsingUnaryOp False" && false);
  }
}
tz_ast_type::CastCatgry tz_ast_utils::ParsingImplicitCast(std::string str) {
  if (str == "IntegralCast") {
    return tz_ast_type::CastCatgry::IntegralCast;
  } else if (str == "FloatingCast") {
    return tz_ast_type::CastCatgry::FloatingCast;
  } else if (str == "LValueToRValue") {
    return tz_ast_type::CastCatgry::LValueToRValue;
  } else if (str == "IntegralToFloating") {
    return tz_ast_type::CastCatgry::IntegralToFloat;
  } else if (str == "FloatingToIntegral") {
    return tz_ast_type::CastCatgry::FloatToIntegral;
  } else if (str == "FunctionToPointerDecay") {
    return tz_ast_type::CastCatgry::FunctionToPointerDecay;
  } else if (str == "ArrayToPointerDecay") {
    return tz_ast_type::CastCatgry::ArrayToPointerDecay;
  } else if (str == "BitCast") {
    return tz_ast_type::CastCatgry::BitCast;
  } else if (str == "NoOp") {
    return tz_ast_type::CastCatgry::NoOp;
  } else {
    assert("ParsingImplicitCast False" && false);
  }
}
std::string tz_ast_utils::Unescape(const std::string &str) {
  std::string result;
  for (std::size_t i = 0; i < str.length(); ++i) {
    if (str[i] == '\\') {
      ++i;
      if (i == str.length()) {
        // The string ends with a backslash
        assert("Invalid escape sequence ends with a backslash" && false);
      }
      switch (str[i]) {
        case 'n':
          result += '\n';
          break;
        case 't':
          result += '\t';
          break;
        case '\\':
          result += '\\';
          break;
        case '\"':
          result += '\"';
          break;
        case '\'':
          result += '\'';
          break;
        case 'r':
          result += '\r';
          break;
        case 'v':
          result += '\v';
          break;
        case 'f':
          result += '\f';
          break;
        case 'a':
          result += '\a';
          break;
        case 'b':
          result += '\b';
          break;
        default:
          // Unknown escape sequence
          assert("Invalid escape sequence ends with a backslash" && false);
      }
    } else {
      result += str[i];
    }
  }
  return result;
}

int tz_ast_utils::ConvertMatToVec(llvm::Type *_ArrayType) {
  int MatrixSize = 1;
  while (auto arraytype = llvm::dyn_cast<llvm::ArrayType>(_ArrayType)) {
    MatrixSize *= arraytype->getNumElements();
    _ArrayType = arraytype->getElementType();
  }
  return MatrixSize;
}

/********************************
 * IR Emit Implementations
 ********************************/

std::vector<tz_ast_utils::WhileRangeControl> WhileStack;

/********************************
 *  Expr
 *  Literal: IntegerLiteral, FloatingLiteral, StringLiteral
 *  BinaryExpr
 *  UnaryExpr
 *  CallExpr
 *  DeclRefExpr
 *  ImplicitCastExpr
 *  InitListExpr
 *  ArraySubscriptExpr
 ********************************/

llvm::BasicBlock *tz_ast_class::IntegerLiteral::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  *ReturnValue = value;
  return PrevBB;
}

llvm::BasicBlock *tz_ast_class::FloatingLiteral::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  *ReturnValue = value;
  return PrevBB;
}

llvm::BasicBlock *tz_ast_class::StringLiteral::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  *ReturnValue = value;
  return PrevBB;
}

llvm::BasicBlock *tz_ast_class::BinaryExpr::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {}

llvm::BasicBlock *tz_ast_class::UnaryExpr::emit(llvm::Module &TheModule,
                                                llvm::LLVMContext &llvm_context,
                                                llvm::BasicBlock *PrevBB,
                                                llvm::Value **ReturnValue) {}

llvm::BasicBlock *tz_ast_class::CallExpr::emit(llvm::Module &TheModule,
                                               llvm::LLVMContext &llvm_context,
                                               llvm::BasicBlock *PrevBB,
                                               llvm::Value **ReturnValue) {}

llvm::BasicBlock *tz_ast_class::DeclRefExpr::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {}

llvm::BasicBlock *tz_ast_class::ImplicitCastExpr::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  // Finished! TODO(tocheck): Big implementation problems, rebuild.
  // Implementation similar to parsing.
  auto CurrentBB = PrevBB;
  llvm::IRBuilder<> builder(CurrentBB);
  llvm::Value *castValue = nullptr;
  CurrentBB = castExpr->emit(TheModule, llvm_context, CurrentBB, &castValue);
  switch (CastCatgry) {
    case tz_ast_type::IntegralCast: {
      builder.SetInsertPoint(CurrentBB);
      if (type->isIntegerTy()) {
        *ReturnValue = builder.CreateIntCast(castValue, type, false);
      } else if (type->isFloatingPointTy()) {
        *ReturnValue = builder.CreateFPCast(castValue, type);
      } else {
        assert("IntegralCast Failure" && false);
      }
      break;
    }
    case tz_ast_type::FloatingCast: {
      builder.SetInsertPoint(CurrentBB);
      if (type->isIntegerTy()) {
        *ReturnValue = builder.CreateFPToSI(castValue, type);
      } else if (type->isFloatingPointTy()) {
        *ReturnValue = builder.CreateFPCast(castValue, type);
      } else {
        assert("FloatingCast Failure" && false);
      }
      break;
    }
    case tz_ast_type::LValueToRValue: {
      builder.SetInsertPoint(CurrentBB);
      *ReturnValue = builder.CreateLoad(castValue);
      break;
    }
    case tz_ast_type::IntegralToFloat: {
      builder.SetInsertPoint(CurrentBB);
      *ReturnValue = builder.CreateSIToFP(castValue, type);
      break;
    }
    case tz_ast_type::FloatToIntegral: {
      builder.SetInsertPoint(CurrentBB);
      *ReturnValue = builder.CreateFPToSI(castValue, type);
      break;
    }
    case tz_ast_type::FunctionToPointerDecay: {
      auto FunctionPtr = castValue;
      auto TheFunction = TheModule.getFunction(FunctionPtr->getName());
      if (TheFunction == nullptr) {
        assert(false && "function not found");
      }
      *ReturnValue = TheFunction;
      break;
    }
    case tz_ast_type::ArrayToPointerDecay:
    case tz_ast_type::BitCast:
    case tz_ast_type::NoOp: {
      // Has already emitted at the beginning
      break;
    }
    default: {
      assert("EmittingImplicitCast False" && false);
      break;
    }
  }
  return CurrentBB;
}

llvm::BasicBlock *tz_ast_class::InitListExpr::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {}

llvm::BasicBlock *tz_ast_class::ArraySubscriptExpr::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  // Function: get the value in matrix
  auto CurrentBB = PrevBB;
  // Handle Base
  llvm::Value *BasePtr = nullptr;
  CurrentBB = ArrayBase->emit(TheModule, llvm_context, CurrentBB, &BasePtr);
  // Handle Index
  llvm::Value *IndexPtr = nullptr;
  CurrentBB = ArrayBase->emit(TheModule, llvm_context, CurrentBB, &IndexPtr);

  // Flatten the matrix
  int MatrixSize = tz_ast_utils::ConvertMatToVec(type);

  // Emit IRs
  llvm::IRBuilder<> builder(CurrentBB);
  auto offset = builder.CreateMul(
      IndexPtr, llvm::ConstantInt::get(IndexPtr->getType(), MatrixSize));
  auto newArrayPtr = builder.CreateInBoundsGEP(BasePtr, {offset});
  *ReturnValue = newArrayPtr;
  return CurrentBB;
}
llvm::BasicBlock *tz_ast_class::ParenExpr::emit(llvm::Module &TheModule,
                                                llvm::LLVMContext &llvm_context,
                                                llvm::BasicBlock *PrevBB,
                                                llvm::Value **ReturnValue) {
  return inParenExpr->emit(TheModule, llvm_context, PrevBB, ReturnValue);
}
/********************************
 *  Decl
 *  TranslationUnitDecl
 *  VarDecl
 *  ParmVarDecl
 *  FunctionDecl
 ********************************/
llvm::BasicBlock *tz_ast_class::TranslationUnitDecl::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  // assert("TranslationUnitDecl has no body!" && false);
  if (Decls.size()) {
    for (auto &Decl : Decls) {
      assert("Decl is empty!" && Decl != nullptr);
      PrevBB = Decl->emit(TheModule, llvm_context, PrevBB, ReturnValue);
    }
  }
  return PrevBB;
}
llvm::BasicBlock *tz_ast_class::VarDecl::emit(llvm::Module &TheModule,
                                              llvm::LLVMContext &llvm_context,
                                              llvm::BasicBlock *PrevBB,
                                              llvm::Value **ReturnValue) {}
llvm::BasicBlock *tz_ast_class::ParmVarDecl::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {}
llvm::BasicBlock *tz_ast_class::FunctionDecl::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {}

/********************************
 *  Stmt
 *  CompoundStmt
 *  ReturnStmt
 *  IfStmt
 *  WhileStmt
 *  DoStmt
 *  NullStmt
 *  BreakStmt
 *  ContinueStmt
 *  DeclStmt
 ********************************/

llvm::BasicBlock *tz_ast_class::CompoundStmt::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  // Traverse the stmts and return the latest BB InnerStmts
  auto LatestBB = PrevBB;
  for (auto &InnerStmt : InnerStmts) {
    LatestBB = InnerStmt->emit(TheModule, llvm_context, LatestBB, nullptr);
    assert("CompoundStmt has build a null stmt" && LatestBB != nullptr);
  }
  return LatestBB;
}
llvm::BasicBlock *tz_ast_class::ReturnStmt::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  llvm::IRBuilder<> builder(PrevBB);
  if (ReturnExpr != nullptr) {
    llvm::Value *retValue = nullptr;
    ReturnExpr->emit(TheModule, llvm_context, PrevBB, &retValue);
    // builder.SetInsertPoint(BB);
    // auto retval = LocalNamedValues["retval"];
    // builder.CreateStore(retValue, retval);
    // builder.CreateBr(retBB);
    // BB->moveBefore(retBB);
    builder.CreateRet(retValue);

  } else {
    // builder.CreateBr(retBB);
    // BB->moveBefore(retBB);
    builder.CreateRetVoid();
  }
  // Return ,so no BB is to follow
  return nullptr;
}
llvm::BasicBlock *tz_ast_class::IfStmt::emit(llvm::Module &TheModule,
                                             llvm::LLVMContext &llvm_context,
                                             llvm::BasicBlock *PrevBB,
                                             llvm::Value **ReturnValue) {
  bool TerminateAtThen = false;
  bool TerminateAtElse = false;
  auto CurrentParentFunction = PrevBB->getParent();

  auto ifthenBB =
      llvm::BasicBlock::Create(llvm_context, "ifThen", CurrentParentFunction);
  auto ifendBB = llvm::BasicBlock::Create(llvm_context, "ifEnd", nullptr);

  // Handle the Condtion
  llvm::IRBuilder<> builder_cond(PrevBB);
  llvm::Value *CondValue = nullptr;
  PrevBB = IfCondExpr->emit(TheModule, llvm_context, PrevBB, &CondValue);
  builder_cond.SetInsertPoint(PrevBB);

  // Check Condition Value
  auto type = CondValue->getType();
  if (type->isIntegerTy(1)) {
    // Bool
    CondValue = CondValue;
  } else if (type->isIntegerTy()) {
    // Interger
    CondValue =
        builder_cond.CreateICmpNE(CondValue, llvm::ConstantInt::get(type, 0));
  } else if (type->isFloatingPointTy()) {
    // Float
    CondValue =
        builder_cond.CreateFCmpONE(CondValue, llvm::ConstantFP::get(type, 0));
  } else {
    assert("Wrong Condition Type" && false);
  }

  if (hasElse) {
    auto ifelseBB =
        llvm::BasicBlock::Create(llvm_context, "ifElse", CurrentParentFunction);

    // Short_Circut Handle:
    builder_cond.CreateCondBr(CondValue, ifthenBB, ifelseBB);

    // Handle ifthen
    llvm::IRBuilder<> builder_ifthen(ifthenBB);
    llvm::Value *useless_retvalue = nullptr;
    ifthenBB =
        ThenObj->emit(TheModule, llvm_context, ifthenBB, &useless_retvalue);

    // Finished! TODO(To be simplified): Fix terminator stuff
    if (ifthenBB != nullptr && ifthenBB->getTerminator() == nullptr) {
      if (ifendBB->getParent() == nullptr) {
        ifendBB->insertInto(CurrentParentFunction);
      }
      builder_ifthen.SetInsertPoint(ifthenBB);
      builder_ifthen.CreateBr(ifendBB);
      TerminateAtThen = true;
    }

    // Handle ifelse
    llvm::IRBuilder<> builder_ifelse(ifelseBB);
    useless_retvalue = nullptr;
    ifelseBB =
        ElseObj->emit(TheModule, llvm_context, ifelseBB, &useless_retvalue);

    if (ifelseBB != nullptr && ifelseBB->getTerminator() == nullptr) {
      if (ifendBB->getParent() == nullptr) {
        ifendBB->insertInto(CurrentParentFunction);
      }
      builder_ifelse.SetInsertPoint(ifelseBB);
      builder_ifelse.CreateBr(ifendBB);
      TerminateAtElse = true;
    }
    if (!TerminateAtThen && !TerminateAtElse) {
      return nullptr;
    } else {
      return ifendBB;
    }
  } else {
    builder_cond.CreateCondBr(CondValue, ifthenBB, ifendBB);

    // Handle ifthen
    llvm::IRBuilder<> builder_ifthen(ifthenBB);
    llvm::Value *useless_retvalue = nullptr;
    ifthenBB =
        ThenObj->emit(TheModule, llvm_context, ifthenBB, &useless_retvalue);

    if (ifthenBB != nullptr && ifthenBB->getTerminator() == nullptr) {
      builder_ifthen.SetInsertPoint(ifthenBB);
      builder_ifthen.CreateBr(ifendBB);
    }

    return ifendBB;
  }
}
llvm::BasicBlock *tz_ast_class::WhileStmt::emit(llvm::Module &TheModule,
                                                llvm::LLVMContext &llvm_context,
                                                llvm::BasicBlock *PrevBB,
                                                llvm::Value **ReturnValue) {
  auto CurrentParentFunction = PrevBB->getParent();

  // While is a loop structure, we need to maintain the jump relation
  llvm::BasicBlock *WhileCondBeginBB = llvm::BasicBlock::Create(
      llvm_context, "whileCond", CurrentParentFunction);
  llvm::BasicBlock *WhileCondEndBB = WhileCondBeginBB;
  llvm::BasicBlock *WhileBodyBeginBB = llvm::BasicBlock::Create(
      llvm_context, "whileBody", CurrentParentFunction);
  llvm::BasicBlock *WhileBodyEndBB = WhileBodyBeginBB;
  llvm::BasicBlock *WhileEndBB =
      llvm::BasicBlock::Create(llvm_context, "whileEnd", CurrentParentFunction);

  // Maintain the stack
  WhileStack.push_back(
      tz_ast_utils::WhileRangeControl(WhileCondBeginBB, WhileBodyEndBB));

  // Handle the Condtion
  llvm::IRBuilder<> builder_cond_begin(PrevBB);
  builder_cond_begin.CreateBr(WhileCondBeginBB);

  llvm::IRBuilder<> builder_cond(WhileCondEndBB);
  llvm::Value *CondValue = nullptr;
  WhileCondEndBB =
      WhileCondExpr->emit(TheModule, llvm_context, WhileCondEndBB, &CondValue);
  builder_cond.SetInsertPoint(WhileCondEndBB);

  // Check Condition Value
  auto type = CondValue->getType();
  if (type->isIntegerTy(1)) {
    // Bool
    CondValue = CondValue;
  } else if (type->isIntegerTy()) {
    // Interger
    CondValue =
        builder_cond.CreateICmpNE(CondValue, llvm::ConstantInt::get(type, 0));
  } else if (type->isFloatingPointTy()) {
    // Float
    CondValue =
        builder_cond.CreateFCmpONE(CondValue, llvm::ConstantFP::get(type, 0));
  } else {
    assert("Wrong Condition Type" && false);
  }
  // May be finished. TODO(the flow to be checked)! may be wrong.
  builder_cond.CreateCondBr(CondValue, WhileBodyBeginBB, WhileEndBB);

  // Handle the body
  llvm::IRBuilder<> builder_whilebody(WhileBodyEndBB);
  llvm::Value *useless_retvalue = nullptr;
  WhileBodyEndBB = WhileObj->emit(TheModule, llvm_context, WhileBodyEndBB,
                                  &useless_retvalue);
  // Maintain the terminate relationship
  if (WhileBodyEndBB != nullptr && WhileBodyEndBB->getTerminator() == nullptr) {
    builder_whilebody.SetInsertPoint(WhileBodyEndBB);
    builder_whilebody.CreateBr(WhileCondBeginBB);
  }

  WhileStack.pop_back();

  return WhileEndBB;
}
llvm::BasicBlock *tz_ast_class::DoStmt::emit(llvm::Module &TheModule,
                                             llvm::LLVMContext &llvm_context,
                                             llvm::BasicBlock *PrevBB,
                                             llvm::Value **ReturnValue) {
  // Totally the same as while
  auto CurrentParentFunction = PrevBB->getParent();

  // Do is a loop structure, we need to maintain the jump relation
  llvm::BasicBlock *DoCondBeginBB =
      llvm::BasicBlock::Create(llvm_context, "doCond", CurrentParentFunction);
  llvm::BasicBlock *DoCondEndBB = DoCondBeginBB;
  llvm::BasicBlock *DoBodyBeginBB =
      llvm::BasicBlock::Create(llvm_context, "doBody", CurrentParentFunction);
  llvm::BasicBlock *DoBodyEndBB = DoBodyBeginBB;
  llvm::BasicBlock *DoEndBB =
      llvm::BasicBlock::Create(llvm_context, "doEnd", CurrentParentFunction);

  // Maintain the stack
  WhileStack.push_back(
      tz_ast_utils::WhileRangeControl(DoCondBeginBB, DoBodyEndBB));

  // Handle the Condtion
  llvm::IRBuilder<> builder_cond_begin(PrevBB);
  builder_cond_begin.CreateBr(DoCondBeginBB);

  llvm::IRBuilder<> builder_cond(DoCondEndBB);
  llvm::Value *CondValue = nullptr;
  DoCondEndBB =
      DoCondExpr->emit(TheModule, llvm_context, DoCondEndBB, &CondValue);
  builder_cond.SetInsertPoint(DoCondEndBB);

  // Check Condition Value
  auto type = CondValue->getType();
  if (type->isIntegerTy(1)) {
    // Bool
    CondValue = CondValue;
  } else if (type->isIntegerTy()) {
    // Interger
    CondValue =
        builder_cond.CreateICmpNE(CondValue, llvm::ConstantInt::get(type, 0));
  } else if (type->isFloatingPointTy()) {
    // Float
    CondValue =
        builder_cond.CreateFCmpONE(CondValue, llvm::ConstantFP::get(type, 0));
  } else {
    assert("Wrong Condition Type" && false);
  }
  // May be finished. TODO(the flow to be checked)! may be wrong.
  builder_cond.CreateCondBr(CondValue, DoBodyBeginBB, DoEndBB);

  // Handle the body
  llvm::IRBuilder<> builder_whilebody(DoBodyEndBB);
  llvm::Value *useless_retvalue = nullptr;
  DoBodyEndBB =
      DoObj->emit(TheModule, llvm_context, DoBodyEndBB, &useless_retvalue);
  // Maintain the terminate relationship
  if (DoBodyEndBB != nullptr && DoBodyEndBB->getTerminator() == nullptr) {
    builder_whilebody.SetInsertPoint(DoBodyEndBB);
    builder_whilebody.CreateBr(DoCondBeginBB);
  }

  WhileStack.pop_back();

  return DoEndBB;
}
llvm::BasicBlock *tz_ast_class::NullStmt::emit(llvm::Module &TheModule,
                                               llvm::LLVMContext &llvm_context,
                                               llvm::BasicBlock *PrevBB,
                                               llvm::Value **ReturnValue) {
  // Do nothing
  return PrevBB;
}
llvm::BasicBlock *tz_ast_class::BreakStmt::emit(llvm::Module &TheModule,
                                                llvm::LLVMContext &llvm_context,
                                                llvm::BasicBlock *PrevBB,
                                                llvm::Value **ReturnValue) {
  llvm::IRBuilder<> builder(PrevBB);
  assert("No while! While Contorl Range Failure." && WhileStack.size() > 0);
  auto &whileEnd = WhileStack.back().whileEnd;
  builder.CreateBr(whileEnd);
  // PrevBB->moveBefore(whileEndStak.back());
  return PrevBB;
}
llvm::BasicBlock *tz_ast_class::ContinueStmt::emit(
    llvm::Module &TheModule, llvm::LLVMContext &llvm_context,
    llvm::BasicBlock *PrevBB, llvm::Value **ReturnValue) {
  llvm::IRBuilder<> builder(PrevBB);
  assert("No while! While Contorl Range Failure." && WhileStack.size() > 0);
  auto &whileEnd = WhileStack.back().whileBegin;
  builder.CreateBr(whileEnd);
  // PrevBB->moveBefore(whileEndStak.back());
  return PrevBB;
}
llvm::BasicBlock *tz_ast_class::DeclStmt::emit(llvm::Module &TheModule,
                                               llvm::LLVMContext &llvm_context,
                                               llvm::BasicBlock *PrevBB,
                                               llvm::Value **ReturnValue) {
  auto CurrentBB = PrevBB;
  if (Decls.size()) {
    for (auto &Decl : Decls) {
      assert("Decl in Decls is Null!" && false);
      CurrentBB = Decl->emit(TheModule, llvm_context, CurrentBB, nullptr);
    }
  }
  return CurrentBB;
}